<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>C++ Rest SDK: Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cloud.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Rest SDK
   </div>
   <div id="projectbrief">The C++ REST SDK is a Microsoft project for cloud-based client-server communication in native code using a modern asynchronous C++ API design. This project aims to help C++ developers connect to and interact with services.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Concurrency</b></li><li class="navelem"><a class="el" href="namespace_concurrency_1_1streams.html">streams</a></li><li class="navelem"><b>details</b></li><li class="navelem"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">basic_container_buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html" title="The basic_container_buffer class serves as a memory-based steam buffer that supports writing or readi...">basic_container_buffer</a> class serves as a memory-based steam buffer that supports writing or reading sequences of characters. The class itself should not be used in application code, it is used by the stream definitions farther down in the header file.  
 <a href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="containerstream_8h_source.html">containerstream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.png" usemap="#Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;_map" alt=""/>
  <map id="Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;_map" name="Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;_map">
<area href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html" alt="Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;" shape="rect" coords="268,56,795,80"/>
<area href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html" alt="Concurrency::streams::details::basic_streambuf&lt; _CollectionType::value_type &gt;" shape="rect" coords="0,0,527,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a87855ac930d4dceb9dadc8ac3679703d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87855ac930d4dceb9dadc8ac3679703d"></a>
typedef _CollectionType::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>_CharType</b></td></tr>
<tr class="separator:a87855ac930d4dceb9dadc8ac3679703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08566d0df39963f93f283b6fb1bc858"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae08566d0df39963f93f283b6fb1bc858"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">basic_streambuf</a>&lt; _CharType &gt;::traits&#160;</td><td class="memItemRight" valign="bottom"><b>traits</b></td></tr>
<tr class="separator:ae08566d0df39963f93f283b6fb1bc858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9612e58e316a335e3130b8326158ba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9612e58e316a335e3130b8326158ba7"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">basic_streambuf</a>&lt; _CharType &gt;::int_type&#160;</td><td class="memItemRight" valign="bottom"><b>int_type</b></td></tr>
<tr class="separator:af9612e58e316a335e3130b8326158ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1120c92dc74e00e4f5cb29226c1171f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1120c92dc74e00e4f5cb29226c1171f9"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">basic_streambuf</a>&lt; _CharType &gt;::pos_type&#160;</td><td class="memItemRight" valign="bottom"><b>pos_type</b></td></tr>
<tr class="separator:a1120c92dc74e00e4f5cb29226c1171f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1fd5a1a2da892f133139f78cad080f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f1fd5a1a2da892f133139f78cad080f"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">basic_streambuf</a>&lt; _CharType &gt;::off_type&#160;</td><td class="memItemRight" valign="bottom"><b>off_type</b></td></tr>
<tr class="separator:a9f1fd5a1a2da892f133139f78cad080f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a></td></tr>
<tr class="memitem:afd16abf255509d80388b99f9d9625343 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd16abf255509d80388b99f9d9625343"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">details::basic_streambuf</a>&lt; _CollectionType::value_type &gt;::traits&#160;</td><td class="memItemRight" valign="bottom"><b>traits</b></td></tr>
<tr class="separator:afd16abf255509d80388b99f9d9625343 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514a823a5b04ed3710087a7ed60ac9e6 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a514a823a5b04ed3710087a7ed60ac9e6"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">details::basic_streambuf</a>&lt; _CollectionType::value_type &gt;::int_type&#160;</td><td class="memItemRight" valign="bottom"><b>int_type</b></td></tr>
<tr class="separator:a514a823a5b04ed3710087a7ed60ac9e6 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f724e70ef1c92e0e22452a65001b2fb inherit pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f724e70ef1c92e0e22452a65001b2fb"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">details::basic_streambuf</a>&lt; _CollectionType::value_type &gt;::pos_type&#160;</td><td class="memItemRight" valign="bottom"><b>pos_type</b></td></tr>
<tr class="separator:a9f724e70ef1c92e0e22452a65001b2fb inherit pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb7d6a6fee0bc2a0e9ee1eb5bc8e6d5 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cb7d6a6fee0bc2a0e9ee1eb5bc8e6d5"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">details::basic_streambuf</a>&lt; _CollectionType::value_type &gt;::off_type&#160;</td><td class="memItemRight" valign="bottom"><b>off_type</b></td></tr>
<tr class="separator:a3cb7d6a6fee0bc2a0e9ee1eb5bc8e6d5 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf&lt; _CollectionType::value_type &gt;</a></td></tr>
<tr class="memitem:a7cd70561849f966823d4534aa38963ad inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cd70561849f966823d4534aa38963ad"></a>
typedef _CollectionType::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>char_type</b></td></tr>
<tr class="separator:a7cd70561849f966823d4534aa38963ad inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc879afd2840d1df21fe86248910052 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dc879afd2840d1df21fe86248910052"></a>
typedef ::concurrency::streams::char_traits&lt; _CollectionType::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>traits</b></td></tr>
<tr class="separator:a7dc879afd2840d1df21fe86248910052 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ff619438b3e71e6f601bb518a67a9 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a079ff619438b3e71e6f601bb518a67a9"></a>
typedef traits::int_type&#160;</td><td class="memItemRight" valign="bottom"><b>int_type</b></td></tr>
<tr class="separator:a079ff619438b3e71e6f601bb518a67a9 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139102a6d042dc709717b97d2565fcf3 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a139102a6d042dc709717b97d2565fcf3"></a>
typedef traits::pos_type&#160;</td><td class="memItemRight" valign="bottom"><b>pos_type</b></td></tr>
<tr class="separator:a139102a6d042dc709717b97d2565fcf3 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e021e969ca85d498840d5adee6f02e3 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e021e969ca85d498840d5adee6f02e3"></a>
typedef traits::off_type&#160;</td><td class="memItemRight" valign="bottom"><b>off_type</b></td></tr>
<tr class="separator:a9e021e969ca85d498840d5adee6f02e3 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a647343e25058b17cd73afe12cf5ff47e"><td class="memItemLeft" align="right" valign="top">_CollectionType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a647343e25058b17cd73afe12cf5ff47e">collection</a> ()</td></tr>
<tr class="memdesc:a647343e25058b17cd73afe12cf5ff47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying data container  <a href="#a647343e25058b17cd73afe12cf5ff47e">More...</a><br /></td></tr>
<tr class="separator:a647343e25058b17cd73afe12cf5ff47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3b3b249c171c5c9f249e93b8e3e8e7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#aab3b3b249c171c5c9f249e93b8e3e8e7">~basic_container_buffer</a> ()</td></tr>
<tr class="memdesc:aab3b3b249c171c5c9f249e93b8e3e8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor  <a href="#aab3b3b249c171c5c9f249e93b8e3e8e7">More...</a><br /></td></tr>
<tr class="separator:aab3b3b249c171c5c9f249e93b8e3e8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a></td></tr>
<tr class="memitem:aed2334bda427e1aab975a6ddc9179187 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aed2334bda427e1aab975a6ddc9179187">can_read</a> () const</td></tr>
<tr class="memdesc:aed2334bda427e1aab975a6ddc9179187 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>can_read</code> is used to determine whether a stream buffer will support read operations (get).  <a href="#aed2334bda427e1aab975a6ddc9179187">More...</a><br /></td></tr>
<tr class="separator:aed2334bda427e1aab975a6ddc9179187 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548ca961ef6062e52094679745b5a3c2 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a548ca961ef6062e52094679745b5a3c2">can_write</a> () const</td></tr>
<tr class="memdesc:a548ca961ef6062e52094679745b5a3c2 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>can_write</code> is used to determine whether a stream buffer will support write operations (put).  <a href="#a548ca961ef6062e52094679745b5a3c2">More...</a><br /></td></tr>
<tr class="separator:a548ca961ef6062e52094679745b5a3c2 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae803b65c032ea6e9dcd54b92e0c9d512 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ae803b65c032ea6e9dcd54b92e0c9d512">is_open</a> () const</td></tr>
<tr class="memdesc:ae803b65c032ea6e9dcd54b92e0c9d512 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream buffer is open.  <a href="#ae803b65c032ea6e9dcd54b92e0c9d512">More...</a><br /></td></tr>
<tr class="separator:ae803b65c032ea6e9dcd54b92e0c9d512 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e2852cda70d6424ef8787ebbd3c25f inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#af7e2852cda70d6424ef8787ebbd3c25f">close</a> (std::ios_base::openmode mode=std::ios_base::in|std::ios_base::out)</td></tr>
<tr class="memdesc:af7e2852cda70d6424ef8787ebbd3c25f inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream buffer, preventing further read or write operations.  <a href="#af7e2852cda70d6424ef8787ebbd3c25f">More...</a><br /></td></tr>
<tr class="separator:af7e2852cda70d6424ef8787ebbd3c25f inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749a8c69f0c9870ab534ebe2b1e0914c inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a749a8c69f0c9870ab534ebe2b1e0914c">close</a> (std::ios_base::openmode mode, std::exception_ptr eptr)</td></tr>
<tr class="memdesc:a749a8c69f0c9870ab534ebe2b1e0914c inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream buffer with an exception.  <a href="#a749a8c69f0c9870ab534ebe2b1e0914c">More...</a><br /></td></tr>
<tr class="separator:a749a8c69f0c9870ab534ebe2b1e0914c inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ec23de40fe0390b6eeed04ac352de1 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a70ec23de40fe0390b6eeed04ac352de1">is_eof</a> () const</td></tr>
<tr class="memdesc:a70ec23de40fe0390b6eeed04ac352de1 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_eof</code> is used to determine whether a read head has reached the end of the buffer.  <a href="#a70ec23de40fe0390b6eeed04ac352de1">More...</a><br /></td></tr>
<tr class="separator:a70ec23de40fe0390b6eeed04ac352de1 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380b990b895a20224ca45d6c7c11190c inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a380b990b895a20224ca45d6c7c11190c">putc</a> (_CollectionType::value_type ch)</td></tr>
<tr class="memdesc:a380b990b895a20224ca45d6c7c11190c inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single character to the stream.  <a href="#a380b990b895a20224ca45d6c7c11190c">More...</a><br /></td></tr>
<tr class="separator:a380b990b895a20224ca45d6c7c11190c inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4927b4f17f050f1fd10ed599cb49b836 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a4927b4f17f050f1fd10ed599cb49b836">putn</a> (const _CollectionType::value_type *ptr, size_t count)</td></tr>
<tr class="memdesc:a4927b4f17f050f1fd10ed599cb49b836 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a number of characters to the stream.  <a href="#a4927b4f17f050f1fd10ed599cb49b836">More...</a><br /></td></tr>
<tr class="separator:a4927b4f17f050f1fd10ed599cb49b836 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48557a7d9d216500f879abc912b5f24f inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a48557a7d9d216500f879abc912b5f24f">putn_nocopy</a> (const _CollectionType::value_type *ptr, size_t count)</td></tr>
<tr class="memdesc:a48557a7d9d216500f879abc912b5f24f inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a number of characters to the stream. Note: callers must make sure the data to be written is valid until the returned task completes.  <a href="#a48557a7d9d216500f879abc912b5f24f">More...</a><br /></td></tr>
<tr class="separator:a48557a7d9d216500f879abc912b5f24f inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9f0ad2b5ddf49b316751aa18a9cf58 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2e9f0ad2b5ddf49b316751aa18a9cf58">bumpc</a> ()</td></tr>
<tr class="memdesc:a2e9f0ad2b5ddf49b316751aa18a9cf58 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream and advances the read position.  <a href="#a2e9f0ad2b5ddf49b316751aa18a9cf58">More...</a><br /></td></tr>
<tr class="separator:a2e9f0ad2b5ddf49b316751aa18a9cf58 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f5fd8cab84a41d75e8476015e83331 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa3f5fd8cab84a41d75e8476015e83331">sbumpc</a> ()</td></tr>
<tr class="memdesc:aa3f5fd8cab84a41d75e8476015e83331 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream and advances the read position.  <a href="#aa3f5fd8cab84a41d75e8476015e83331">More...</a><br /></td></tr>
<tr class="separator:aa3f5fd8cab84a41d75e8476015e83331 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c5d6cdc4f5dfcdd2859b4fa3872c95 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa6c5d6cdc4f5dfcdd2859b4fa3872c95">getc</a> ()</td></tr>
<tr class="memdesc:aa6c5d6cdc4f5dfcdd2859b4fa3872c95 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream without advancing the read position.  <a href="#aa6c5d6cdc4f5dfcdd2859b4fa3872c95">More...</a><br /></td></tr>
<tr class="separator:aa6c5d6cdc4f5dfcdd2859b4fa3872c95 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9df9f0e827354a4f3d673e6d2643f52 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ac9df9f0e827354a4f3d673e6d2643f52">sgetc</a> ()</td></tr>
<tr class="memdesc:ac9df9f0e827354a4f3d673e6d2643f52 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream without advancing the read position.  <a href="#ac9df9f0e827354a4f3d673e6d2643f52">More...</a><br /></td></tr>
<tr class="separator:ac9df9f0e827354a4f3d673e6d2643f52 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee850cc04e3ca57084ab11523e1db2e inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#acee850cc04e3ca57084ab11523e1db2e">nextc</a> ()</td></tr>
<tr class="memdesc:acee850cc04e3ca57084ab11523e1db2e inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the read position, then returns the next character without advancing again.  <a href="#acee850cc04e3ca57084ab11523e1db2e">More...</a><br /></td></tr>
<tr class="separator:acee850cc04e3ca57084ab11523e1db2e inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2c264214da39baadca7755be4a9e0e inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a5c2c264214da39baadca7755be4a9e0e">ungetc</a> ()</td></tr>
<tr class="memdesc:a5c2c264214da39baadca7755be4a9e0e inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retreats the read position, then returns the current character without advancing.  <a href="#a5c2c264214da39baadca7755be4a9e0e">More...</a><br /></td></tr>
<tr class="separator:a5c2c264214da39baadca7755be4a9e0e inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e03bfa260c8b9a2678e86c1c980c3a5 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2e03bfa260c8b9a2678e86c1c980c3a5">getn</a> (_Out_writes_(count) _CollectionType::value_type *ptr, _In_ size_t count)</td></tr>
<tr class="memdesc:a2e03bfa260c8b9a2678e86c1c980c3a5 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads up to a given number of characters from the stream.  <a href="#a2e03bfa260c8b9a2678e86c1c980c3a5">More...</a><br /></td></tr>
<tr class="separator:a2e03bfa260c8b9a2678e86c1c980c3a5 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac759d4d90e6b33da98ed8f495c138dd8 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ac759d4d90e6b33da98ed8f495c138dd8">scopy</a> (_Out_writes_(count) _CollectionType::value_type *ptr, _In_ size_t count)</td></tr>
<tr class="memdesc:ac759d4d90e6b33da98ed8f495c138dd8 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to a given number of characters from the stream, synchronously.  <a href="#ac759d4d90e6b33da98ed8f495c138dd8">More...</a><br /></td></tr>
<tr class="separator:ac759d4d90e6b33da98ed8f495c138dd8 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747f7e31451884a9448be43d11680285 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a747f7e31451884a9448be43d11680285">sync</a> ()</td></tr>
<tr class="memdesc:a747f7e31451884a9448be43d11680285 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">For output streams, flush any internally buffered data to the underlying medium.  <a href="#a747f7e31451884a9448be43d11680285">More...</a><br /></td></tr>
<tr class="separator:a747f7e31451884a9448be43d11680285 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd1d77a11059cc5f7f379b54bf56e53 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2fd1d77a11059cc5f7f379b54bf56e53">exception</a> () const</td></tr>
<tr class="memdesc:a2fd1d77a11059cc5f7f379b54bf56e53 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stream buffer exception_ptr if it has been set.  <a href="#a2fd1d77a11059cc5f7f379b54bf56e53">More...</a><br /></td></tr>
<tr class="separator:a2fd1d77a11059cc5f7f379b54bf56e53 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7637174c543cfe0a900a40e1a7c8df15 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">_CollectionType::value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a7637174c543cfe0a900a40e1a7c8df15">alloc</a> (size_t count)</td></tr>
<tr class="memdesc:a7637174c543cfe0a900a40e1a7c8df15 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a contiguous memory block and returns it.  <a href="#a7637174c543cfe0a900a40e1a7c8df15">More...</a><br /></td></tr>
<tr class="separator:a7637174c543cfe0a900a40e1a7c8df15 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e07f5f2e05a4e176353b901acc326d inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#af0e07f5f2e05a4e176353b901acc326d">commit</a> (size_t count)</td></tr>
<tr class="memdesc:af0e07f5f2e05a4e176353b901acc326d inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a block already allocated by the stream buffer.  <a href="#af0e07f5f2e05a4e176353b901acc326d">More...</a><br /></td></tr>
<tr class="separator:af0e07f5f2e05a4e176353b901acc326d inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb84f15b01c2133012b1c1b7e8be8b0 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacb84f15b01c2133012b1c1b7e8be8b0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>acquire</b> (_Out_writes_(count) _CollectionType::value_type *&amp;ptr, _In_ size_t &amp;count)=0</td></tr>
<tr class="separator:aacb84f15b01c2133012b1c1b7e8be8b0 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68390e9e8286f7911bde2dd91bbbf209 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> (_Out_writes_(count) _CollectionType::value_type *ptr, _In_ size_t count)=0</td></tr>
<tr class="memdesc:a68390e9e8286f7911bde2dd91bbbf209 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a block of data acquired using ::acquire method. This frees the stream buffer to de-allocate the memory, if it so desires. Move the read position ahead by the count.  <a href="#a68390e9e8286f7911bde2dd91bbbf209">More...</a><br /></td></tr>
<tr class="separator:a68390e9e8286f7911bde2dd91bbbf209 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf&lt; _CollectionType::value_type &gt;</a></td></tr>
<tr class="memitem:ae8d7242e86aa6bfba080a18afcdf610b inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#ae8d7242e86aa6bfba080a18afcdf610b">~basic_streambuf</a> ()</td></tr>
<tr class="memdesc:ae8d7242e86aa6bfba080a18afcdf610b inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor for stream buffers.  <a href="#ae8d7242e86aa6bfba080a18afcdf610b">More...</a><br /></td></tr>
<tr class="separator:ae8d7242e86aa6bfba080a18afcdf610b inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcdb3c58237bcae05dd7a5649fb25e9 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top">virtual _CollectionType::value_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a5fcdb3c58237bcae05dd7a5649fb25e9">alloc</a> (_In_ size_t count)=0</td></tr>
<tr class="memdesc:a5fcdb3c58237bcae05dd7a5649fb25e9 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a contiguous memory block and returns it.  <a href="#a5fcdb3c58237bcae05dd7a5649fb25e9">More...</a><br /></td></tr>
<tr class="separator:a5fcdb3c58237bcae05dd7a5649fb25e9 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019704086210ed4d54f009cb9105a118 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a019704086210ed4d54f009cb9105a118">commit</a> (_In_ size_t count)=0</td></tr>
<tr class="memdesc:a019704086210ed4d54f009cb9105a118 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a block already allocated by the stream buffer.  <a href="#a019704086210ed4d54f009cb9105a118">More...</a><br /></td></tr>
<tr class="separator:a019704086210ed4d54f009cb9105a118 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af343d4627e24beac6726778d9d69622d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#af343d4627e24beac6726778d9d69622d">can_seek</a> () const </td></tr>
<tr class="memdesc:af343d4627e24beac6726778d9d69622d"><td class="mdescLeft">&#160;</td><td class="mdescRight">can_seek is used to determine whether a stream buffer supports seeking.  <a href="#af343d4627e24beac6726778d9d69622d">More...</a><br /></td></tr>
<tr class="separator:af343d4627e24beac6726778d9d69622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e0854abbf6e1002372e5ffff3c4b97"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a95e0854abbf6e1002372e5ffff3c4b97">has_size</a> () const </td></tr>
<tr class="memdesc:a95e0854abbf6e1002372e5ffff3c4b97"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>has_size<code> is used to determine whether a stream buffer supports <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a7ba5b293e0e73d0e09ddc67fb398899c" title="Gets the size of the stream, if known. Calls to has_size will determine whether the result of size ca...">size()</a>. </code></code><code><code> </code></code> <a href="#a95e0854abbf6e1002372e5ffff3c4b97">More...</a><br /></td></tr>
<tr class="separator:a95e0854abbf6e1002372e5ffff3c4b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba5b293e0e73d0e09ddc67fb398899c"><td class="memItemLeft" align="right" valign="top">virtual utility::size64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a7ba5b293e0e73d0e09ddc67fb398899c">size</a> () const </td></tr>
<tr class="memdesc:a7ba5b293e0e73d0e09ddc67fb398899c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the stream, if known. Calls to <code>has_size</code> will determine whether the result of <code>size</code> can be relied on.  <a href="#a7ba5b293e0e73d0e09ddc67fb398899c">More...</a><br /></td></tr>
<tr class="separator:a7ba5b293e0e73d0e09ddc67fb398899c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa1f184f84d1084c18328e69c4c8791"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#acaa1f184f84d1084c18328e69c4c8791">buffer_size</a> (std::ios_base::openmode=std::ios_base::in) const </td></tr>
<tr class="memdesc:acaa1f184f84d1084c18328e69c4c8791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stream buffer size, if one has been set.  <a href="#acaa1f184f84d1084c18328e69c4c8791">More...</a><br /></td></tr>
<tr class="separator:acaa1f184f84d1084c18328e69c4c8791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d303f2025cb5160ed7d06d0b26a768"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#ad0d303f2025cb5160ed7d06d0b26a768">set_buffer_size</a> (size_t, std::ios_base::openmode=std::ios_base::in)</td></tr>
<tr class="memdesc:ad0d303f2025cb5160ed7d06d0b26a768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stream buffer implementation to buffer or not buffer.  <a href="#ad0d303f2025cb5160ed7d06d0b26a768">More...</a><br /></td></tr>
<tr class="separator:ad0d303f2025cb5160ed7d06d0b26a768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38043172f7d0b9a36b45f52c1c57205"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#ac38043172f7d0b9a36b45f52c1c57205">in_avail</a> () const </td></tr>
<tr class="memdesc:ac38043172f7d0b9a36b45f52c1c57205"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any input stream, <code>in_avail</code> returns the number of characters that are immediately available to be consumed without blocking. May be used in conjunction with &lt;cref="::sbumpc method"/&gt; to read data without incurring the overhead of using tasks.  <a href="#ac38043172f7d0b9a36b45f52c1c57205">More...</a><br /></td></tr>
<tr class="separator:ac38043172f7d0b9a36b45f52c1c57205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5670ffe61266e579d6b34fac67f35c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5670ffe61266e579d6b34fac67f35c2"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_sync</b> ()</td></tr>
<tr class="separator:af5670ffe61266e579d6b34fac67f35c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937df8bf0a9033177fb810a0c11c903f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a937df8bf0a9033177fb810a0c11c903f"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_putc</b> (_CharType ch)</td></tr>
<tr class="separator:a937df8bf0a9033177fb810a0c11c903f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4f87e317be6d77fe5893822399b078"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc4f87e317be6d77fe5893822399b078"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_putn</b> (const _CharType *ptr, size_t count)</td></tr>
<tr class="separator:acc4f87e317be6d77fe5893822399b078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1210ef4e56839eede201fd5bf7d9dd"><td class="memItemLeft" align="right" valign="top">_CharType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a2d1210ef4e56839eede201fd5bf7d9dd">_alloc</a> (size_t count)</td></tr>
<tr class="memdesc:a2d1210ef4e56839eede201fd5bf7d9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a contiguous memory block and returns it.  <a href="#a2d1210ef4e56839eede201fd5bf7d9dd">More...</a><br /></td></tr>
<tr class="separator:a2d1210ef4e56839eede201fd5bf7d9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575137425d6998ee52732d90125880c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a575137425d6998ee52732d90125880c7">_commit</a> (size_t actual)</td></tr>
<tr class="memdesc:a575137425d6998ee52732d90125880c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a block already allocated by the stream buffer.  <a href="#a575137425d6998ee52732d90125880c7">More...</a><br /></td></tr>
<tr class="separator:a575137425d6998ee52732d90125880c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb5c5fae35d57415d42d412c9e84ce0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#aebb5c5fae35d57415d42d412c9e84ce0">acquire</a> (_Out_ _CharType *&amp;ptr, _Out_ size_t &amp;count)</td></tr>
<tr class="memdesc:aebb5c5fae35d57415d42d412c9e84ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the next already allocated contiguous block of data.  <a href="#aebb5c5fae35d57415d42d412c9e84ce0">More...</a><br /></td></tr>
<tr class="separator:aebb5c5fae35d57415d42d412c9e84ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b921431c5eea856f4fec536ce58d673"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a5b921431c5eea856f4fec536ce58d673">release</a> (_Out_writes_opt_(count) _CharType *ptr, _In_ size_t count)</td></tr>
<tr class="memdesc:a5b921431c5eea856f4fec536ce58d673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a block of data acquired using ::acquire method. This frees the stream buffer to de-allocate the memory, if it so desires. Move the read position ahead by the count.  <a href="#a5b921431c5eea856f4fec536ce58d673">More...</a><br /></td></tr>
<tr class="separator:a5b921431c5eea856f4fec536ce58d673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2e7909e5fead26b36cf11eeea23e01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f2e7909e5fead26b36cf11eeea23e01"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_getn</b> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)</td></tr>
<tr class="separator:a4f2e7909e5fead26b36cf11eeea23e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe7ac4d60a95186d7edca3da568b625"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefe7ac4d60a95186d7edca3da568b625"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_sgetn</b> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)</td></tr>
<tr class="separator:aefe7ac4d60a95186d7edca3da568b625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4c3e146636867d2dca5bbddd7ef159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb4c3e146636867d2dca5bbddd7ef159"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_scopy</b> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)</td></tr>
<tr class="separator:acb4c3e146636867d2dca5bbddd7ef159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf189c0a78a59255b212c5dffcacdab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bf189c0a78a59255b212c5dffcacdab"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_bumpc</b> ()</td></tr>
<tr class="separator:a9bf189c0a78a59255b212c5dffcacdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9edcca7304dac64a0e679a1a9dc76a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f9edcca7304dac64a0e679a1a9dc76a"></a>
virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><b>_sbumpc</b> ()</td></tr>
<tr class="separator:a9f9edcca7304dac64a0e679a1a9dc76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ed5d1a686125452c8b9d6bc364a524"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52ed5d1a686125452c8b9d6bc364a524"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_getc</b> ()</td></tr>
<tr class="separator:a52ed5d1a686125452c8b9d6bc364a524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba87ddcb3b43632de96e8ad69c376d21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba87ddcb3b43632de96e8ad69c376d21"></a>
int_type&#160;</td><td class="memItemRight" valign="bottom"><b>_sgetc</b> ()</td></tr>
<tr class="separator:aba87ddcb3b43632de96e8ad69c376d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fff7c7e7f778a333f07f88c4440282"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65fff7c7e7f778a333f07f88c4440282"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_nextc</b> ()</td></tr>
<tr class="separator:a65fff7c7e7f778a333f07f88c4440282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2383149888eca1860d850bbb9033fae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2383149888eca1860d850bbb9033fae"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_ungetc</b> ()</td></tr>
<tr class="separator:ae2383149888eca1860d850bbb9033fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5930518c77994f3000dc0cd3ac1e39c7"><td class="memItemLeft" align="right" valign="top">virtual pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a5930518c77994f3000dc0cd3ac1e39c7">getpos</a> (std::ios_base::openmode mode) const </td></tr>
<tr class="memdesc:a5930518c77994f3000dc0cd3ac1e39c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current read or write position in the stream.  <a href="#a5930518c77994f3000dc0cd3ac1e39c7">More...</a><br /></td></tr>
<tr class="separator:a5930518c77994f3000dc0cd3ac1e39c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04c4bd7ed732a85db022f94337dd265"><td class="memItemLeft" align="right" valign="top">virtual pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#aa04c4bd7ed732a85db022f94337dd265">seekpos</a> (pos_type position, std::ios_base::openmode mode)</td></tr>
<tr class="memdesc:aa04c4bd7ed732a85db022f94337dd265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeks to the given position.  <a href="#aa04c4bd7ed732a85db022f94337dd265">More...</a><br /></td></tr>
<tr class="separator:aa04c4bd7ed732a85db022f94337dd265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84838b4b0c8744033a66502af46c08e1"><td class="memItemLeft" align="right" valign="top">virtual pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a84838b4b0c8744033a66502af46c08e1">seekoff</a> (off_type offset, std::ios_base::seekdir way, std::ios_base::openmode mode)</td></tr>
<tr class="memdesc:a84838b4b0c8744033a66502af46c08e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeks to a position given by a relative offset.  <a href="#a84838b4b0c8744033a66502af46c08e1">More...</a><br /></td></tr>
<tr class="separator:a84838b4b0c8744033a66502af46c08e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a></td></tr>
<tr class="memitem:a7ea2b71412d16332b0abe8fe4dad2e2d inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea2b71412d16332b0abe8fe4dad2e2d"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_putn</b> (const _CollectionType::value_type *ptr, size_t count, bool)</td></tr>
<tr class="separator:a7ea2b71412d16332b0abe8fe4dad2e2d inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa006a004495768b97e9718ef89a675f1 inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa006a004495768b97e9718ef89a675f1">_close_read</a> ()</td></tr>
<tr class="memdesc:aa006a004495768b97e9718ef89a675f1 inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">The real read head close operation, implementation should override it if there is any resource to be released.  <a href="#aa006a004495768b97e9718ef89a675f1">More...</a><br /></td></tr>
<tr class="separator:aa006a004495768b97e9718ef89a675f1 inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bd370ba0b9a6e75e29a0d80903db34 inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ad9bd370ba0b9a6e75e29a0d80903db34">_close_write</a> ()</td></tr>
<tr class="memdesc:ad9bd370ba0b9a6e75e29a0d80903db34 inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">The real write head close operation, implementation should override it if there is any resource to be released.  <a href="#ad9bd370ba0b9a6e75e29a0d80903db34">More...</a><br /></td></tr>
<tr class="separator:ad9bd370ba0b9a6e75e29a0d80903db34 inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025ea08f6676b593619704b56fc0c674 inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a025ea08f6676b593619704b56fc0c674"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>streambuf_state_manager</b> (std::ios_base::openmode mode)</td></tr>
<tr class="separator:a025ea08f6676b593619704b56fc0c674 inherit pro_methods_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6c0dbb51efafac916f57688bfbb8bda9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c0dbb51efafac916f57688bfbb8bda9"></a>
template&lt;typename _CollectionType1 &gt; </td></tr>
<tr class="memitem:a6c0dbb51efafac916f57688bfbb8bda9"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>streams::container_buffer</b></td></tr>
<tr class="separator:a6c0dbb51efafac916f57688bfbb8bda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a></td></tr>
<tr class="memitem:abbb9ccb5164574d23a5672f5b7dcdf23 inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbb9ccb5164574d23a5672f5b7dcdf23"></a>
std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>m_currentException</b></td></tr>
<tr class="separator:abbb9ccb5164574d23a5672f5b7dcdf23 inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2936187fac4351285569e86f44b9484 inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2936187fac4351285569e86f44b9484"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_stream_can_read</b></td></tr>
<tr class="separator:ad2936187fac4351285569e86f44b9484 inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d42ecf51cc3a19c97803387d07d2af inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02d42ecf51cc3a19c97803387d07d2af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_stream_can_write</b></td></tr>
<tr class="separator:a02d42ecf51cc3a19c97803387d07d2af inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e7b95c3e1c2c3326ef63af05a50bb2 inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71e7b95c3e1c2c3326ef63af05a50bb2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_stream_read_eof</b></td></tr>
<tr class="separator:a71e7b95c3e1c2c3326ef63af05a50bb2 inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca050fcb2116f7e1558674bf7624c172 inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca050fcb2116f7e1558674bf7624c172"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_alloced</b></td></tr>
<tr class="separator:aca050fcb2116f7e1558674bf7624c172 inherit pro_attribs_class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _CollectionType&gt;<br />
class Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</h3>

<p>The <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html" title="The basic_container_buffer class serves as a memory-based steam buffer that supports writing or readi...">basic_container_buffer</a> class serves as a memory-based steam buffer that supports writing or reading sequences of characters. The class itself should not be used in application code, it is used by the stream definitions farther down in the header file. </p>
<p>When closed, neither writing nor reading is supported any longer. <code><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html" title="The basic_container_buffer class serves as a memory-based steam buffer that supports writing or readi...">basic_container_buffer</a></code> does not support simultaneous use of the buffer for reading and writing.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aab3b3b249c171c5c9f249e93b8e3e8e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::~<a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">basic_container_buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2d1210ef4e56839eede201fd5bf7d9dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_CharType* <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a contiguous memory block and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of characters to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a block to write to, null if the stream buffer implementation does not support alloc/commit.</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a575137425d6998ee52732d90125880c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::_commit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>actual</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a block already allocated by the stream buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of characters to be committed.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aebb5c5fae35d57415d42d412c9e84ce0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::acquire </td>
          <td>(</td>
          <td class="paramtype">_Out_ _CharType *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Out_ size_t &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to the next already allocated contiguous block of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A reference to a pointer variable that will hold the address of the block on success.</td></tr>
    <tr><td class="paramname">count</td><td>The number of contiguous characters available at the address in 'ptr.'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation succeeded, <code>false</code> otherwise.</dd></dl>
<p>A return of false does not necessarily indicate that a subsequent read operation would fail, only that there is no block to return immediately or that the stream buffer does not support the operation. The stream buffer may not de-allocate the block until ::release method is called. If the end of the stream is reached, the function will return <code>true</code>, a null pointer, and a count of zero; a subsequent read will not succeed. </p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#aafc68282f1bfa06b97e09380e3b64405">Concurrency::streams::details::basic_streambuf&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="acaa1f184f84d1084c18328e69c4c8791"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::buffer_size </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"> = <code>std::ios_base::in</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stream buffer size, if one has been set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The direction of buffering (in or out)</td></tr>
  </table>
  </dd>
</dl>
<p>An implementation that does not support buffering will always return '0'.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a909ec3a6fc564cb06937aff9cea896b0">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af343d4627e24beac6726778d9d69622d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::can_seek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>can_seek is used to determine whether a stream buffer supports seeking. </p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a76fc42530539a84f98b1d1f48cb2fcd0">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a647343e25058b17cd73afe12cf5ff47e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_CollectionType&amp; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::collection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying data container </p>

</div>
</div>
<a class="anchor" id="a5930518c77994f3000dc0cd3ac1e39c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::getpos </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current read or write position in the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The I/O direction to seek (see remarks)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current position. EOF if the operation fails.</dd></dl>
<p>Some streams may have separate write and read cursors. For such streams, the direction parameter defines whether to move the read or the write cursor.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a4acd807ca4d033cef91de1acd4f41fc3">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a95e0854abbf6e1002372e5ffff3c4b97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::has_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>has_size<code> is used to determine whether a stream buffer supports <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a7ba5b293e0e73d0e09ddc67fb398899c" title="Gets the size of the stream, if known. Calls to has_size will determine whether the result of size ca...">size()</a>. </code></code><code><code> </code></code></p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a1e719975f42244d923c72e2e322faa07">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac38043172f7d0b9a36b45f52c1c57205"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::in_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For any input stream, <code>in_avail</code> returns the number of characters that are immediately available to be consumed without blocking. May be used in conjunction with &lt;cref="::sbumpc method"/&gt; to read data without incurring the overhead of using tasks. </p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a1e02ea1d54f3b1203787616bf8340430">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5b921431c5eea856f4fec536ce58d673"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::release </td>
          <td>(</td>
          <td class="paramtype">_Out_writes_opt_(count) _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_In_ size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a block of data acquired using ::acquire method. This frees the stream buffer to de-allocate the memory, if it so desires. Move the read position ahead by the count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the block of data to be released.</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters that were read.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84838b4b0c8744033a66502af46c08e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::seekoff </td>
          <td>(</td>
          <td class="paramtype">off_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::seekdir&#160;</td>
          <td class="paramname"><em>way</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seeks to a position given by a relative offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The relative position to seek to</td></tr>
    <tr><td class="paramname">way</td><td>The starting point (beginning, end, current) for the seek.</td></tr>
    <tr><td class="paramname">mode</td><td>The I/O direction to seek (see remarks)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position. EOF if the operation fails.</dd></dl>
<p>Some streams may have separate write and read cursors. For such streams, the mode parameter defines whether to move the read or the write cursor.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2d7a83da4fc15bda3e02dbc91d21bc2a">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa04c4bd7ed732a85db022f94337dd265"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::seekpos </td>
          <td>(</td>
          <td class="paramtype">pos_type&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seeks to the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The offset from the beginning of the stream.</td></tr>
    <tr><td class="paramname">direction</td><td>The I/O direction to seek (see remarks).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position. EOF if the operation fails.</dd></dl>
<p>Some streams may have separate write and read cursors. For such streams, the direction parameter defines whether to move the read or the write cursor.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a771c9acc022390635bad4453f59a44dc">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad0d303f2025cb5160ed7d06d0b26a768"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::set_buffer_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"> = <code>std::ios_base::in</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the stream buffer implementation to buffer or not buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to use for internal buffering, 0 if no buffering should be done.</td></tr>
    <tr><td class="paramname">direction</td><td>The direction of buffering (in or out)</td></tr>
  </table>
  </dd>
</dl>
<p>An implementation that does not support buffering will silently ignore calls to this function and it will not have any effect on what is returned by subsequent calls to ::buffer_size method.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a302f500fe45a006d6e264d320f87b3e9">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7ba5b293e0e73d0e09ddc67fb398899c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CollectionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual utility::size64_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html">Concurrency::streams::details::basic_container_buffer</a>&lt; _CollectionType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the stream, if known. Calls to <code>has_size</code> will determine whether the result of <code>size</code> can be relied on. </p>

<p>Reimplemented from <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a6d2e4ca19b7eda6cd5348768d9c3f548">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cpprest/<a class="el" href="containerstream_8h_source.html">containerstream.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
