<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>C++ Rest SDK: web::http::details::http_msg_base Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cloud.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Rest SDK
   </div>
   <div id="projectbrief">The C++ REST SDK is a Microsoft project for cloud-based client-server communication in native code using a modern asynchronous C++ API design. This project aims to help C++ developers connect to and interact with services.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceweb.html">web</a></li><li class="navelem"><a class="el" href="namespaceweb_1_1http.html">http</a></li><li class="navelem"><b>details</b></li><li class="navelem"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html">http_msg_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classweb_1_1http_1_1details_1_1http__msg__base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">web::http::details::http_msg_base Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for HTTP messages. This class is to store common functionality so it isn't duplicated on both the request and response side.  
 <a href="classweb_1_1http_1_1details_1_1http__msg__base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="http__msg_8h_source.html">http_msg.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for web::http::details::http_msg_base:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classweb_1_1http_1_1details_1_1http__msg__base.png" usemap="#web::http::details::http_msg_base_map" alt=""/>
  <map id="web::http::details::http_msg_base_map" name="web::http::details::http_msg_base_map">
<area href="classweb_1_1http_1_1details_1_1__http__request.html" title="Internal representation of an HTTP request message. " alt="web::http::details::_http_request" shape="rect" coords="0,56,195,80"/>
<area href="classweb_1_1http_1_1details_1_1__http__response.html" title="Internal representation of an HTTP response. " alt="web::http::details::_http_response" shape="rect" coords="205,56,400,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2515a7c83e89b4487d98a1f14bc69aed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2515a7c83e89b4487d98a1f14bc69aed"></a>
<a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>headers</b> ()</td></tr>
<tr class="separator:a2515a7c83e89b4487d98a1f14bc69aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7f9f3766ad26ebf4ede0250d4b9594"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff7f9f3766ad26ebf4ede0250d4b9594"></a>
_ASYNCRTIMP void&#160;</td><td class="memItemRight" valign="bottom"><b>set_body</b> (const concurrency::streams::istream &amp;<a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#acca11fe632e7990b4d2a65519f1ca2f0">instream</a>, const utf8string &amp;contentType)</td></tr>
<tr class="separator:aff7f9f3766ad26ebf4ede0250d4b9594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5452ec3d8496c29b7c50166fc898619"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5452ec3d8496c29b7c50166fc898619"></a>
_ASYNCRTIMP void&#160;</td><td class="memItemRight" valign="bottom"><b>set_body</b> (const concurrency::streams::istream &amp;<a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#acca11fe632e7990b4d2a65519f1ca2f0">instream</a>, const utf16string &amp;contentType)</td></tr>
<tr class="separator:ab5452ec3d8496c29b7c50166fc898619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcb3fae911847b174cc07e91981f9dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fcb3fae911847b174cc07e91981f9dd"></a>
_ASYNCRTIMP void&#160;</td><td class="memItemRight" valign="bottom"><b>set_body</b> (const concurrency::streams::istream &amp;<a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#acca11fe632e7990b4d2a65519f1ca2f0">instream</a>, utility::size64_t contentLength, const utf8string &amp;contentType)</td></tr>
<tr class="separator:a3fcb3fae911847b174cc07e91981f9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3070d8d7283dcba06a0e50ead1280e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef3070d8d7283dcba06a0e50ead1280e"></a>
_ASYNCRTIMP void&#160;</td><td class="memItemRight" valign="bottom"><b>set_body</b> (const concurrency::streams::istream &amp;<a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#acca11fe632e7990b4d2a65519f1ca2f0">instream</a>, utility::size64_t contentLength, const utf16string &amp;contentType)</td></tr>
<tr class="separator:aef3070d8d7283dcba06a0e50ead1280e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf7d9a6e2130bb43ecbb50e0d3b394c"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a0cf7d9a6e2130bb43ecbb50e0d3b394c">parse_and_check_content_type</a> (bool ignore_content_type, const std::function&lt; bool(const utility::string_t &amp;)&gt; &amp;check_content_type)</td></tr>
<tr class="memdesc:a0cf7d9a6e2130bb43ecbb50e0d3b394c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for extract functions. Parses the Content-Type header and check to make sure it matches, throws an exception if not.  <a href="#a0cf7d9a6e2130bb43ecbb50e0d3b394c">More...</a><br /></td></tr>
<tr class="separator:a0cf7d9a6e2130bb43ecbb50e0d3b394c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba2b03e8cd3857254f4e3ab38b7f16c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeba2b03e8cd3857254f4e3ab38b7f16c"></a>
_ASYNCRTIMP utf8string&#160;</td><td class="memItemRight" valign="bottom"><b>extract_utf8string</b> (bool ignore_content_type=false)</td></tr>
<tr class="separator:aeba2b03e8cd3857254f4e3ab38b7f16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ca94e4ecf653f25c4797421f70b7d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41ca94e4ecf653f25c4797421f70b7d0"></a>
_ASYNCRTIMP utf16string&#160;</td><td class="memItemRight" valign="bottom"><b>extract_utf16string</b> (bool ignore_content_type=false)</td></tr>
<tr class="separator:a41ca94e4ecf653f25c4797421f70b7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb42f048b05fbc3bdb83c2284dbe9fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cb42f048b05fbc3bdb83c2284dbe9fb"></a>
_ASYNCRTIMP utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><b>extract_string</b> (bool ignore_content_type=false)</td></tr>
<tr class="separator:a9cb42f048b05fbc3bdb83c2284dbe9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245019f340c1af124d02bdd4e08162fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a245019f340c1af124d02bdd4e08162fe"></a>
_ASYNCRTIMP <a class="el" href="classweb_1_1json_1_1value.html">json::value</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_extract_json</b> (bool ignore_content_type=false)</td></tr>
<tr class="separator:a245019f340c1af124d02bdd4e08162fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af028ac3cd7a6f9c579de56ad73a0e335"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af028ac3cd7a6f9c579de56ad73a0e335"></a>
_ASYNCRTIMP std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_extract_vector</b> ()</td></tr>
<tr class="separator:af028ac3cd7a6f9c579de56ad73a0e335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a313375538a23374236da776bc36c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3a313375538a23374236da776bc36c3"></a>
virtual _ASYNCRTIMP utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> () const </td></tr>
<tr class="separator:ad3a313375538a23374236da776bc36c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd70e200d8d6001c2ccc424ab139d83"><td class="memItemLeft" align="right" valign="top">virtual _ASYNCRTIMP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a4cd70e200d8d6001c2ccc424ab139d83">_complete</a> (utility::size64_t bodySize, const std::exception_ptr &amp;exceptionPtr=std::exception_ptr())</td></tr>
<tr class="memdesc:a4cd70e200d8d6001c2ccc424ab139d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes this message  <a href="#a4cd70e200d8d6001c2ccc424ab139d83">More...</a><br /></td></tr>
<tr class="separator:a4cd70e200d8d6001c2ccc424ab139d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad758b458da3051b05c8c2c22453754d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#ad758b458da3051b05c8c2c22453754d3">set_instream</a> (const concurrency::streams::istream &amp;<a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#acca11fe632e7990b4d2a65519f1ca2f0">instream</a>)</td></tr>
<tr class="memdesc:ad758b458da3051b05c8c2c22453754d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stream through which the message body could be read  <a href="#ad758b458da3051b05c8c2c22453754d3">More...</a><br /></td></tr>
<tr class="separator:ad758b458da3051b05c8c2c22453754d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca11fe632e7990b4d2a65519f1ca2f0"><td class="memItemLeft" align="right" valign="top">const concurrency::streams::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#acca11fe632e7990b4d2a65519f1ca2f0">instream</a> () const </td></tr>
<tr class="memdesc:acca11fe632e7990b4d2a65519f1ca2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stream through which the message body could be read  <a href="#acca11fe632e7990b4d2a65519f1ca2f0">More...</a><br /></td></tr>
<tr class="separator:acca11fe632e7990b4d2a65519f1ca2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ebf9e29561e7fbb0dd649f246a7933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a89ebf9e29561e7fbb0dd649f246a7933">set_outstream</a> (const concurrency::streams::ostream &amp;<a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a72f095e8243a5ee7c8c35965e710bfdb">outstream</a>, bool is_default)</td></tr>
<tr class="memdesc:a89ebf9e29561e7fbb0dd649f246a7933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stream through which the message body could be written  <a href="#a89ebf9e29561e7fbb0dd649f246a7933">More...</a><br /></td></tr>
<tr class="separator:a89ebf9e29561e7fbb0dd649f246a7933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f095e8243a5ee7c8c35965e710bfdb"><td class="memItemLeft" align="right" valign="top">const concurrency::streams::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a72f095e8243a5ee7c8c35965e710bfdb">outstream</a> () const </td></tr>
<tr class="memdesc:a72f095e8243a5ee7c8c35965e710bfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stream through which the message body could be written  <a href="#a72f095e8243a5ee7c8c35965e710bfdb">More...</a><br /></td></tr>
<tr class="separator:a72f095e8243a5ee7c8c35965e710bfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a504b2f89f24bbec493f5c4c53044b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a504b2f89f24bbec493f5c4c53044b1"></a>
const <a class="el" href="classpplx_1_1task__completion__event.html">pplx::task_completion_event</a>&lt; utility::size64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_get_data_available</b> () const </td></tr>
<tr class="separator:a1a504b2f89f24bbec493f5c4c53044b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2258c432d92e6532fe3d3e522bde6b96"><td class="memItemLeft" align="right" valign="top">_ASYNCRTIMP void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a2258c432d92e6532fe3d3e522bde6b96">_prepare_to_receive_data</a> ()</td></tr>
<tr class="memdesc:a2258c432d92e6532fe3d3e522bde6b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the message with an output stream to receive network data  <a href="#a2258c432d92e6532fe3d3e522bde6b96">More...</a><br /></td></tr>
<tr class="separator:a2258c432d92e6532fe3d3e522bde6b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769de42ace5dc07b1bb2c37bca257d46"><td class="memItemLeft" align="right" valign="top">_ASYNCRTIMP size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a769de42ace5dc07b1bb2c37bca257d46">_get_content_length</a> ()</td></tr>
<tr class="memdesc:a769de42ace5dc07b1bb2c37bca257d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the content length  <a href="#a769de42ace5dc07b1bb2c37bca257d46">More...</a><br /></td></tr>
<tr class="separator:a769de42ace5dc07b1bb2c37bca257d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a87b9b185ec247b383d7663c0143368ed"><td class="memItemLeft" align="right" valign="top">concurrency::streams::istream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a87b9b185ec247b383d7663c0143368ed">m_inStream</a></td></tr>
<tr class="memdesc:a87b9b185ec247b383d7663c0143368ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream to read the message body. By default this is an invalid stream. The user could set the instream on a request by calling set_request_stream(...). This would also be set when set_body() is called - a stream from the body is constructed and set. Even in the presense of msg body this stream could be invalid. An example would be when the user sets an ostream for the response. With that API the user does not provide the ability to read the msg body. Thus m_instream is valid when there is a msg body and it can actually be read  <a href="#a87b9b185ec247b383d7663c0143368ed">More...</a><br /></td></tr>
<tr class="separator:a87b9b185ec247b383d7663c0143368ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05edb98c26a2d801f06ef43ca5352bac"><td class="memItemLeft" align="right" valign="top">concurrency::streams::ostream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a05edb98c26a2d801f06ef43ca5352bac">m_outStream</a></td></tr>
<tr class="memdesc:a05edb98c26a2d801f06ef43ca5352bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">stream to write the msg body By default this is an invalid stream. The user could set this on the response (for http_client). In all the other cases we would construct one to transfer the data from the network into the message body.  <a href="#a05edb98c26a2d801f06ef43ca5352bac">More...</a><br /></td></tr>
<tr class="separator:a05edb98c26a2d801f06ef43ca5352bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abd606e5391e6b1ff21dda26cd2a3bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2abd606e5391e6b1ff21dda26cd2a3bd"></a>
<a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_headers</b></td></tr>
<tr class="separator:a2abd606e5391e6b1ff21dda26cd2a3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157c8d47d1d08e652edefeefafcf5e2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a157c8d47d1d08e652edefeefafcf5e2a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_default_outstream</b></td></tr>
<tr class="separator:a157c8d47d1d08e652edefeefafcf5e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68799f4f4d3bddfff8d8a3b1ee150396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task__completion__event.html">pplx::task_completion_event</a>&lt; utility::size64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1details_1_1http__msg__base.html#a68799f4f4d3bddfff8d8a3b1ee150396">m_data_available</a></td></tr>
<tr class="memdesc:a68799f4f4d3bddfff8d8a3b1ee150396"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TCE is used to signal the availability of the message body.  <a href="#a68799f4f4d3bddfff8d8a3b1ee150396">More...</a><br /></td></tr>
<tr class="separator:a68799f4f4d3bddfff8d8a3b1ee150396"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abba89159a8d6a4bc47e5d2c54ff9debc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abba89159a8d6a4bc47e5d2c54ff9debc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>http::client::http_client</b></td></tr>
<tr class="separator:abba89159a8d6a4bc47e5d2c54ff9debc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for HTTP messages. This class is to store common functionality so it isn't duplicated on both the request and response side. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4cd70e200d8d6001c2ccc424ab139d83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual _ASYNCRTIMP void web::http::details::http_msg_base::_complete </td>
          <td>(</td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>bodySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::exception_ptr &amp;&#160;</td>
          <td class="paramname"><em>exceptionPtr</em> = <code>std::exception_ptr()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes this message </p>

</div>
</div>
<a class="anchor" id="a769de42ace5dc07b1bb2c37bca257d46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_ASYNCRTIMP size_t web::http::details::http_msg_base::_get_content_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the content length </p>
<dl class="section return"><dt>Returns</dt><dd>size_t::max if there is content with unknown length (transfer_encoding:chunked) 0 if there is no content length if there is content with known length </dd></dl>
<p>This routine should only be called after a msg (request/response) has been completely constructed. </p>

</div>
</div>
<a class="anchor" id="a2258c432d92e6532fe3d3e522bde6b96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_ASYNCRTIMP void web::http::details::http_msg_base::_prepare_to_receive_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare the message with an output stream to receive network data </p>

</div>
</div>
<a class="anchor" id="acca11fe632e7990b4d2a65519f1ca2f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const concurrency::streams::istream&amp; web::http::details::http_msg_base::instream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stream through which the message body could be read </p>

</div>
</div>
<a class="anchor" id="a72f095e8243a5ee7c8c35965e710bfdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const concurrency::streams::ostream&amp; web::http::details::http_msg_base::outstream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stream through which the message body could be written </p>

</div>
</div>
<a class="anchor" id="a0cf7d9a6e2130bb43ecbb50e0d3b394c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">utility::string_t web::http::details::http_msg_base::parse_and_check_content_type </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_content_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const utility::string_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>check_content_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for extract functions. Parses the Content-Type header and check to make sure it matches, throws an exception if not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_content_type</td><td>If true ignores the Content-Type header value.</td></tr>
    <tr><td class="paramname">check_content_type</td><td>Function to verify additional information on Content-Type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the charset, an empty string if no Content-Type header is empty.</dd></dl>

</div>
</div>
<a class="anchor" id="ad758b458da3051b05c8c2c22453754d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::details::http_msg_base::set_instream </td>
          <td>(</td>
          <td class="paramtype">const concurrency::streams::istream &amp;&#160;</td>
          <td class="paramname"><em>instream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the stream through which the message body could be read </p>

</div>
</div>
<a class="anchor" id="a89ebf9e29561e7fbb0dd649f246a7933"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::details::http_msg_base::set_outstream </td>
          <td>(</td>
          <td class="paramtype">const concurrency::streams::ostream &amp;&#160;</td>
          <td class="paramname"><em>outstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the stream through which the message body could be written </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a68799f4f4d3bddfff8d8a3b1ee150396"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task__completion__event.html">pplx::task_completion_event</a>&lt;utility::size64_t&gt; web::http::details::http_msg_base::m_data_available</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The TCE is used to signal the availability of the message body. </p>

</div>
</div>
<a class="anchor" id="a87b9b185ec247b383d7663c0143368ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">concurrency::streams::istream web::http::details::http_msg_base::m_inStream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream to read the message body. By default this is an invalid stream. The user could set the instream on a request by calling set_request_stream(...). This would also be set when set_body() is called - a stream from the body is constructed and set. Even in the presense of msg body this stream could be invalid. An example would be when the user sets an ostream for the response. With that API the user does not provide the ability to read the msg body. Thus m_instream is valid when there is a msg body and it can actually be read </p>

</div>
</div>
<a class="anchor" id="a05edb98c26a2d801f06ef43ca5352bac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">concurrency::streams::ostream web::http::details::http_msg_base::m_outStream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>stream to write the msg body By default this is an invalid stream. The user could set this on the response (for http_client). In all the other cases we would construct one to transfer the data from the network into the message body. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cpprest/<a class="el" href="http__msg_8h_source.html">http_msg.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
