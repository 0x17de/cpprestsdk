<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>C++ Rest SDK: web::http::http_request Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">C++ Rest SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceweb.html">web</a></li><li class="navelem"><a class="el" href="namespaceweb_1_1http.html">http</a></li><li class="navelem"><a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classweb_1_1http_1_1http__request-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">web::http::http_request Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents an HTTP request.  
 <a href="classweb_1_1http_1_1http__request.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="http__msg_8h_source.html">http_msg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d7c632f0de4ba389a5218bc071033c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a6d7c632f0de4ba389a5218bc071033c1">http_request</a> ()</td></tr>
<tr class="memdesc:a6d7c632f0de4ba389a5218bc071033c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new HTTP request with the given request method.  <a href="#a6d7c632f0de4ba389a5218bc071033c1">More...</a><br /></td></tr>
<tr class="separator:a6d7c632f0de4ba389a5218bc071033c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2100f0d3d854550c94acae88a2ba46c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a2100f0d3d854550c94acae88a2ba46c5">http_request</a> (<a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a> mtd)</td></tr>
<tr class="memdesc:a2100f0d3d854550c94acae88a2ba46c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new HTTP request with the given request method.  <a href="#a2100f0d3d854550c94acae88a2ba46c5">More...</a><br /></td></tr>
<tr class="separator:a2100f0d3d854550c94acae88a2ba46c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1d55a79d7ae2460dff8c1044c4a61f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#acd1d55a79d7ae2460dff8c1044c4a61f">http_request</a> (const <a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a> &amp;message)</td></tr>
<tr class="memdesc:acd1d55a79d7ae2460dff8c1044c4a61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#acd1d55a79d7ae2460dff8c1044c4a61f">More...</a><br /></td></tr>
<tr class="separator:acd1d55a79d7ae2460dff8c1044c4a61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468dbac9f4ebeeda55308a73f1ccc483"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a468dbac9f4ebeeda55308a73f1ccc483">~http_request</a> ()</td></tr>
<tr class="memdesc:a468dbac9f4ebeeda55308a73f1ccc483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor frees any held resources.  <a href="#a468dbac9f4ebeeda55308a73f1ccc483">More...</a><br /></td></tr>
<tr class="separator:a468dbac9f4ebeeda55308a73f1ccc483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a91b7f7fbb2e65deb0f5f6956c6a9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a32a91b7f7fbb2e65deb0f5f6956c6a9a">operator=</a> (const <a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a> &amp;message)</td></tr>
<tr class="memdesc:a32a91b7f7fbb2e65deb0f5f6956c6a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a32a91b7f7fbb2e65deb0f5f6956c6a9a">More...</a><br /></td></tr>
<tr class="separator:a32a91b7f7fbb2e65deb0f5f6956c6a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9067f56e50c7de2130d57c2b3d19e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a6a9067f56e50c7de2130d57c2b3d19e4">method</a> () const </td></tr>
<tr class="memdesc:a6a9067f56e50c7de2130d57c2b3d19e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the method (GET/PUT/POST/DELETE) of the request message.  <a href="#a6a9067f56e50c7de2130d57c2b3d19e4">More...</a><br /></td></tr>
<tr class="separator:a6a9067f56e50c7de2130d57c2b3d19e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cab7ba239c49edf9748a3de5c7ef3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a44cab7ba239c49edf9748a3de5c7ef3c">set_method</a> (<a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a> <a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">method</a>) const </td></tr>
<tr class="memdesc:a44cab7ba239c49edf9748a3de5c7ef3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the method (GET/PUT/POST/DELETE) of the request message.  <a href="#a44cab7ba239c49edf9748a3de5c7ef3c">More...</a><br /></td></tr>
<tr class="separator:a44cab7ba239c49edf9748a3de5c7ef3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514942581f6117175c6b3e209d10c362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1uri.html">uri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a514942581f6117175c6b3e209d10c362">request_uri</a> () const </td></tr>
<tr class="memdesc:a514942581f6117175c6b3e209d10c362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underling URI of the request message.  <a href="#a514942581f6117175c6b3e209d10c362">More...</a><br /></td></tr>
<tr class="separator:a514942581f6117175c6b3e209d10c362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea3e29c7c8665d35608fc4d51b9a3bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#acea3e29c7c8665d35608fc4d51b9a3bb">set_request_uri</a> (const <a class="el" href="classweb_1_1uri.html">uri</a> &amp;<a class="el" href="classweb_1_1uri.html">uri</a>)</td></tr>
<tr class="memdesc:acea3e29c7c8665d35608fc4d51b9a3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the underling URI of the request message.  <a href="#acea3e29c7c8665d35608fc4d51b9a3bb">More...</a><br /></td></tr>
<tr class="separator:acea3e29c7c8665d35608fc4d51b9a3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8aad665e1c0309ec3f788a4dfc9f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1uri.html">uri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a5f8aad665e1c0309ec3f788a4dfc9f05">relative_uri</a> () const </td></tr>
<tr class="memdesc:a5f8aad665e1c0309ec3f788a4dfc9f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference the URI path, query, and fragment part of this request message. This will be appended to the base URI specified at construction of the http_client.  <a href="#a5f8aad665e1c0309ec3f788a4dfc9f05">More...</a><br /></td></tr>
<tr class="separator:a5f8aad665e1c0309ec3f788a4dfc9f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f8bb329f6a0c9c3131182983d49390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1uri.html">uri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a52f8bb329f6a0c9c3131182983d49390">absolute_uri</a> () const </td></tr>
<tr class="memdesc:a52f8bb329f6a0c9c3131182983d49390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an absolute URI with scheme, host, port, path, query, and fragment part of the request message.  <a href="#a52f8bb329f6a0c9c3131182983d49390">More...</a><br /></td></tr>
<tr class="separator:a52f8bb329f6a0c9c3131182983d49390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a7501be1b05d8361622b877f2bae5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ad1a7501be1b05d8361622b877f2bae5c">headers</a> ()</td></tr>
<tr class="memdesc:ad1a7501be1b05d8361622b877f2bae5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the headers of the response message.  <a href="#ad1a7501be1b05d8361622b877f2bae5c">More...</a><br /></td></tr>
<tr class="separator:ad1a7501be1b05d8361622b877f2bae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54168ed27f3080ea73335b0f397022b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a54168ed27f3080ea73335b0f397022b5">headers</a> () const </td></tr>
<tr class="memdesc:a54168ed27f3080ea73335b0f397022b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a const reference to the headers of the response message.  <a href="#a54168ed27f3080ea73335b0f397022b5">More...</a><br /></td></tr>
<tr class="separator:a54168ed27f3080ea73335b0f397022b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8565af290e048c0168e14bedeaa04a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ad8565af290e048c0168e14bedeaa04a7">extract_string</a> (bool force=false)</td></tr>
<tr class="memdesc:ad8565af290e048c0168e14bedeaa04a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the body of the request message as a string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#ad8565af290e048c0168e14bedeaa04a7">More...</a><br /></td></tr>
<tr class="separator:ad8565af290e048c0168e14bedeaa04a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcba85221768021cd3e52b6358b68573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#afcba85221768021cd3e52b6358b68573">extract_json</a> (bool force=false) const </td></tr>
<tr class="memdesc:afcba85221768021cd3e52b6358b68573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the request message into a json value, checking that the content type is application. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#afcba85221768021cd3e52b6358b68573">More...</a><br /></td></tr>
<tr class="separator:afcba85221768021cd3e52b6358b68573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af328f088cb412491d4ad05fec7ecd964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; std::vector<br class="typebreak" />
&lt; unsigned char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#af328f088cb412491d4ad05fec7ecd964">extract_vector</a> () const </td></tr>
<tr class="memdesc:af328f088cb412491d4ad05fec7ecd964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the body of the response message into a vector of bytes. Extracting a vector can be done on  <a href="#af328f088cb412491d4ad05fec7ecd964">More...</a><br /></td></tr>
<tr class="separator:af328f088cb412491d4ad05fec7ecd964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773b71d91aa4bed6ad3101bbca8215c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a773b71d91aa4bed6ad3101bbca8215c7">set_body</a> (const utility::string_t &amp;body_text, utility::string_t content_type=utility::string_t(_XPLATSTR(&quot;text/plain&quot;)))</td></tr>
<tr class="memdesc:a773b71d91aa4bed6ad3101bbca8215c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is the OS's default code page and will perform appropriate conversions to UTF-8.  <a href="#a773b71d91aa4bed6ad3101bbca8215c7">More...</a><br /></td></tr>
<tr class="separator:a773b71d91aa4bed6ad3101bbca8215c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af947ade6138106cb424c68b8bed9d641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#af947ade6138106cb424c68b8bed9d641">set_body</a> (const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;body_data)</td></tr>
<tr class="memdesc:af947ade6138106cb424c68b8bed9d641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to contain json value. If the 'Content-Type' header hasn't already been set it will be set to 'application/json'.  <a href="#af947ade6138106cb424c68b8bed9d641">More...</a><br /></td></tr>
<tr class="separator:af947ade6138106cb424c68b8bed9d641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb521f63971e5b8664f7e4327e721136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#afb521f63971e5b8664f7e4327e721136">set_body</a> (std::vector&lt; unsigned char &gt; body_data)</td></tr>
<tr class="memdesc:afb521f63971e5b8664f7e4327e721136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'.  <a href="#afb521f63971e5b8664f7e4327e721136">More...</a><br /></td></tr>
<tr class="separator:afb521f63971e5b8664f7e4327e721136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe7ac65ccebdb192192c72e26c7c22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#afbe7ac65ccebdb192192c72e26c7c22e">set_body</a> (concurrency::streams::istream stream, utility::string_t content_type=_XPLATSTR(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:afbe7ac65ccebdb192192c72e26c7c22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to provide the body of the HTTP message when it is sent.  <a href="#afbe7ac65ccebdb192192c72e26c7c22e">More...</a><br /></td></tr>
<tr class="separator:afbe7ac65ccebdb192192c72e26c7c22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a952692c0cfed4140c5018480936aa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a6a952692c0cfed4140c5018480936aa3">set_body</a> (concurrency::streams::istream stream, utility::size64_t content_length, utility::string_t content_type=_XPLATSTR(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:a6a952692c0cfed4140c5018480936aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to provide the body of the HTTP message when it is sent.  <a href="#a6a952692c0cfed4140c5018480936aa3">More...</a><br /></td></tr>
<tr class="separator:a6a952692c0cfed4140c5018480936aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b6309dc6c704aab674d9afcbb3fa01"><td class="memItemLeft" align="right" valign="top">concurrency::streams::istream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ac7b6309dc6c704aab674d9afcbb3fa01">body</a> () const </td></tr>
<tr class="memdesc:ac7b6309dc6c704aab674d9afcbb3fa01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a stream which the caller may use to retrieve data from an incoming request.  <a href="#ac7b6309dc6c704aab674d9afcbb3fa01">More...</a><br /></td></tr>
<tr class="separator:ac7b6309dc6c704aab674d9afcbb3fa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fa7e9676489687b10390ead50540fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ab3fa7e9676489687b10390ead50540fc">set_response_stream</a> (concurrency::streams::ostream stream)</td></tr>
<tr class="memdesc:ab3fa7e9676489687b10390ead50540fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to hold the body of the HTTP response message that results from the request.  <a href="#ab3fa7e9676489687b10390ead50540fc">More...</a><br /></td></tr>
<tr class="separator:ab3fa7e9676489687b10390ead50540fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b43bea37b4baf3a506cc3d3ed71bcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a00b43bea37b4baf3a506cc3d3ed71bcc">set_progress_handler</a> (progress_handler handler)</td></tr>
<tr class="memdesc:a00b43bea37b4baf3a506cc3d3ed71bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a callback function that will be invoked for every chunk of data uploaded or downloaded as part of the request.  <a href="#a00b43bea37b4baf3a506cc3d3ed71bcc">More...</a><br /></td></tr>
<tr class="separator:a00b43bea37b4baf3a506cc3d3ed71bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93bf82aa837bc1c726490beed1d7f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ab93bf82aa837bc1c726490beed1d7f96">reply</a> (<a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> response) const </td></tr>
<tr class="memdesc:ab93bf82aa837bc1c726490beed1d7f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously responses to this HTTP request.  <a href="#ab93bf82aa837bc1c726490beed1d7f96">More...</a><br /></td></tr>
<tr class="separator:ab93bf82aa837bc1c726490beed1d7f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1e5817410850b06abde2b712b6ebce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a7d1e5817410850b06abde2b712b6ebce">reply</a> (http::status_code status) const </td></tr>
<tr class="memdesc:a7d1e5817410850b06abde2b712b6ebce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously responses to this HTTP request.  <a href="#a7d1e5817410850b06abde2b712b6ebce">More...</a><br /></td></tr>
<tr class="separator:a7d1e5817410850b06abde2b712b6ebce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d1463151d1b65f150ae03b2dca447f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a31d1463151d1b65f150ae03b2dca447f">reply</a> (http::status_code status, const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;body_data) const </td></tr>
<tr class="memdesc:a31d1463151d1b65f150ae03b2dca447f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responses to this HTTP request.  <a href="#a31d1463151d1b65f150ae03b2dca447f">More...</a><br /></td></tr>
<tr class="separator:a31d1463151d1b65f150ae03b2dca447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28753794ef4b1b1c84a6c51e3203d577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a28753794ef4b1b1c84a6c51e3203d577">reply</a> (http::status_code status, const utility::string_t &amp;body_data, utility::string_t content_type=_XPLATSTR(&quot;text/plain&quot;)) const </td></tr>
<tr class="memdesc:a28753794ef4b1b1c84a6c51e3203d577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responses to this HTTP request.  <a href="#a28753794ef4b1b1c84a6c51e3203d577">More...</a><br /></td></tr>
<tr class="separator:a28753794ef4b1b1c84a6c51e3203d577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14b5e1def77ea381c0d1472bf1f72fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ab14b5e1def77ea381c0d1472bf1f72fb">reply</a> (status_code status, concurrency::streams::istream <a class="el" href="classweb_1_1http_1_1http__request.html#ac7b6309dc6c704aab674d9afcbb3fa01">body</a>, utility::string_t content_type=_XPLATSTR(&quot;application/octet-stream&quot;)) const </td></tr>
<tr class="memdesc:ab14b5e1def77ea381c0d1472bf1f72fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responses to this HTTP request.  <a href="#ab14b5e1def77ea381c0d1472bf1f72fb">More...</a><br /></td></tr>
<tr class="separator:ab14b5e1def77ea381c0d1472bf1f72fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac600b1435a8c4b76572ab01c4c68a5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ac600b1435a8c4b76572ab01c4c68a5db">reply</a> (status_code status, concurrency::streams::istream <a class="el" href="classweb_1_1http_1_1http__request.html#ac7b6309dc6c704aab674d9afcbb3fa01">body</a>, utility::size64_t content_length, utility::string_t content_type=_XPLATSTR(&quot;application/octet-stream&quot;)) const </td></tr>
<tr class="memdesc:ac600b1435a8c4b76572ab01c4c68a5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responses to this HTTP request.  <a href="#ac600b1435a8c4b76572ab01c4c68a5db">More...</a><br /></td></tr>
<tr class="separator:ac600b1435a8c4b76572ab01c4c68a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a2b663915b4a39c715b09fd8c1df3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a71a2b663915b4a39c715b09fd8c1df3a">content_ready</a> () const </td></tr>
<tr class="memdesc:a71a2b663915b4a39c715b09fd8c1df3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the user (listener) when all the data for this request message has been received.  <a href="#a71a2b663915b4a39c715b09fd8c1df3a">More...</a><br /></td></tr>
<tr class="separator:a71a2b663915b4a39c715b09fd8c1df3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b676982783b8bc89335e5855943c0e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a6b676982783b8bc89335e5855943c0e7">get_response</a> () const </td></tr>
<tr class="memdesc:a6b676982783b8bc89335e5855943c0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a task representing the response that will eventually be sent.  <a href="#a6b676982783b8bc89335e5855943c0e7">More...</a><br /></td></tr>
<tr class="separator:a6b676982783b8bc89335e5855943c0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e95dcdd5f609db1fd4d4ff2dfe4c5d3"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a1e95dcdd5f609db1fd4d4ff2dfe4c5d3">to_string</a> () const </td></tr>
<tr class="memdesc:a1e95dcdd5f609db1fd4d4ff2dfe4c5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string representation of the message, including the body when possible.  <a href="#a1e95dcdd5f609db1fd4d4ff2dfe4c5d3">More...</a><br /></td></tr>
<tr class="separator:a1e95dcdd5f609db1fd4d4ff2dfe4c5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abba89159a8d6a4bc47e5d2c54ff9debc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abba89159a8d6a4bc47e5d2c54ff9debc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>http::client::http_client</b></td></tr>
<tr class="separator:abba89159a8d6a4bc47e5d2c54ff9debc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an HTTP request. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6d7c632f0de4ba389a5218bc071033c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_request::http_request </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new HTTP request with the given request method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Request method.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2100f0d3d854550c94acae88a2ba46c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_request::http_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a>&#160;</td>
          <td class="paramname"><em>mtd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new HTTP request with the given request method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtd</td><td>Request method.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd1d55a79d7ae2460dff8c1044c4a61f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_request::http_request </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="a468dbac9f4ebeeda55308a73f1ccc483"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_request::~http_request </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor frees any held resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a52f8bb329f6a0c9c3131182983d49390"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1uri.html">uri</a> web::http::http_request::absolute_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an absolute URI with scheme, host, port, path, query, and fragment part of the request message. </p>
<p>Absolute URI is only valid after this <a class="el" href="classweb_1_1http_1_1http__request.html" title="Represents an HTTP request. ">http_request</a> object has been passed to http_client::request(). </p>

</div>
</div>
<a class="anchor" id="ac7b6309dc6c704aab674d9afcbb3fa01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">concurrency::streams::istream web::http::http_request::body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces a stream which the caller may use to retrieve data from an incoming request. </p>
<dl class="section return"><dt>Returns</dt><dd>A readable, open asynchronous stream.</dd></dl>
<p>This cannot be used in conjunction with any other means of getting the body of the request. It is not necessary to wait until the message has been sent before starting to write to the stream, but it is advisable to do so, since it will allow the network I/O to start earlier and the work of sending data can be overlapped with the production of more data. </p>

</div>
</div>
<a class="anchor" id="a71a2b663915b4a39c715b09fd8c1df3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a>&gt; web::http::http_request::content_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals the user (listener) when all the data for this request message has been received. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> which is completed when all of the response body has been received</dd></dl>

</div>
</div>
<a class="anchor" id="afcba85221768021cd3e52b6358b68573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1json_1_1value.html">json::value</a>&gt; web::http::http_request::extract_json </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the request message into a json value, checking that the content type is application. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON value from the body of this message.</dd></dl>

</div>
</div>
<a class="anchor" id="ad8565af290e048c0168e14bedeaa04a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;utility::string_t&gt; web::http::http_request::extract_string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the body of the request message as a string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing body of the message.</dd></dl>

</div>
</div>
<a class="anchor" id="af328f088cb412491d4ad05fec7ecd964"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;std::vector&lt;unsigned char&gt; &gt; web::http::http_request::extract_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the body of the response message into a vector of bytes. Extracting a vector can be done on </p>
<dl class="section return"><dt>Returns</dt><dd>The body of the message as a vector of bytes.</dd></dl>

</div>
</div>
<a class="anchor" id="a6b676982783b8bc89335e5855943c0e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a>&gt; web::http::http_request::get_response </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a task representing the response that will eventually be sent. </p>
<dl class="section return"><dt>Returns</dt><dd>A task that is completed once response is sent.</dd></dl>

</div>
</div>
<a class="anchor" id="ad1a7501be1b05d8361622b877f2bae5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a>&amp; web::http::http_request::headers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the headers of the response message. </p>
<dl class="section return"><dt>Returns</dt><dd>HTTP headers for this response.</dd></dl>
<p>Use the <a class="el" href="classweb_1_1http_1_1http__headers.html#aae02146934ff5ad3f7a45307f2ab2660" title="Adds a header field using the &#39;<<&#39; operator. ">http_headers::add</a> to fill in desired headers. </p>

</div>
</div>
<a class="anchor" id="a54168ed27f3080ea73335b0f397022b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a>&amp; web::http::http_request::headers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a const reference to the headers of the response message. </p>
<dl class="section return"><dt>Returns</dt><dd>HTTP headers for this response.</dd></dl>
<p>Use the <a class="el" href="classweb_1_1http_1_1http__headers.html#aae02146934ff5ad3f7a45307f2ab2660" title="Adds a header field using the &#39;<<&#39; operator. ">http_headers::add</a> to fill in desired headers. </p>

</div>
</div>
<a class="anchor" id="a6a9067f56e50c7de2130d57c2b3d19e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a>&amp; web::http::http_request::method </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the method (GET/PUT/POST/DELETE) of the request message. </p>
<dl class="section return"><dt>Returns</dt><dd>Request method of this HTTP request.</dd></dl>

</div>
</div>
<a class="anchor" id="a32a91b7f7fbb2e65deb0f5f6956c6a9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a>&amp; web::http::http_request::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>

</div>
</div>
<a class="anchor" id="a5f8aad665e1c0309ec3f788a4dfc9f05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1uri.html">uri</a> web::http::http_request::relative_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference the URI path, query, and fragment part of this request message. This will be appended to the base URI specified at construction of the http_client. </p>
<dl class="section return"><dt>Returns</dt><dd>A string.</dd></dl>
<p>When the request is the one passed to a listener's handler, the relative URI is the request URI less the listener's path. In all other circumstances, <a class="el" href="classweb_1_1http_1_1http__request.html#a514942581f6117175c6b3e209d10c362" title="Get the underling URI of the request message. ">request_uri()</a> and <a class="el" href="classweb_1_1http_1_1http__request.html#a5f8aad665e1c0309ec3f788a4dfc9f05" title="Gets a reference the URI path, query, and fragment part of this request message. This will be appende...">relative_uri()</a> will return the same value. </p>

</div>
</div>
<a class="anchor" id="ab93bf82aa837bc1c726490beed1d7f96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a>&#160;</td>
          <td class="paramname"><em>response</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously responses to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">response</td><td>Response to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>

</div>
</div>
<a class="anchor" id="a7d1e5817410850b06abde2b712b6ebce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously responses to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>

</div>
</div>
<a class="anchor" id="a31d1463151d1b65f150ae03b2dca447f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;&#160;</td>
          <td class="paramname"><em>body_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responses to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">body_data</td><td>Json value to use in the response body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>

</div>
</div>
<a class="anchor" id="a28753794ef4b1b1c84a6c51e3203d577"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>body_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;text/plain&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responses to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">content_type</td><td>Content type of the body.</td></tr>
    <tr><td class="paramname">body_data</td><td>String containing the text to use in the response body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>
<p>The response may be sent either synchronously or asychronously depending on an internal algorithm on whether we decide or not to copy the body data. Either way callers of this function do NOT need to block waiting for the response to be sent to before the body data is destroyed or goes out of scope. </p>

</div>
</div>
<a class="anchor" id="ab14b5e1def77ea381c0d1472bf1f72fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responses to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
    <tr><td class="paramname">body</td><td>An asynchronous stream representing the body data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A task that is completed once a response from the request is received.</dd></dl>

</div>
</div>
<a class="anchor" id="ac600b1435a8c4b76572ab01c4c68a5db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>content_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responses to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">content_length</td><td>The size of the data to be sent in the body..</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
    <tr><td class="paramname">body</td><td>An asynchronous stream representing the body data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A task that is completed once a response from the request is received.</dd></dl>

</div>
</div>
<a class="anchor" id="a514942581f6117175c6b3e209d10c362"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1uri.html">uri</a> web::http::http_request::request_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underling URI of the request message. </p>
<dl class="section return"><dt>Returns</dt><dd>The uri of this message.</dd></dl>

</div>
</div>
<a class="anchor" id="a773b71d91aa4bed6ad3101bbca8215c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>body_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>utility::string_t(_XPLATSTR(&quot;text/plain&quot;))</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is the OS's default code page and will perform appropriate conversions to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>String containing body text.</td></tr>
    <tr><td class="paramname">content_type</td><td>MIME type to set the "Content-Type" header to. Default to "text/plain".</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data and "Content-Type" header. </p>

</div>
</div>
<a class="anchor" id="af947ade6138106cb424c68b8bed9d641"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to contain json value. If the 'Content-Type' header hasn't already been set it will be set to 'application/json'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>json value.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="afb521f63971e5b8664f7e4327e721136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_data</td><td>Vector containing body data.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="afbe7ac65ccebdb192192c72e26c7c22e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to provide the body of the HTTP message when it is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A readable, open asynchronous stream.</td></tr>
  </table>
  </dd>
</dl>
<p>This cannot be used in conjunction with any other means of setting the body of the request. The stream will not be read until the message is sent. </p>

</div>
</div>
<a class="anchor" id="a6a952692c0cfed4140c5018480936aa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>content_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to provide the body of the HTTP message when it is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A readable, open asynchronous stream.</td></tr>
    <tr><td class="paramname">content_length</td><td>The size of the data to be sent in the body.</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
  </table>
  </dd>
</dl>
<p>This cannot be used in conjunction with any other means of setting the body of the request. The stream will not be read until the message is sent. </p>

</div>
</div>
<a class="anchor" id="a44cab7ba239c49edf9748a3de5c7ef3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the method (GET/PUT/POST/DELETE) of the request message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Request method of this HTTP request.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00b43bea37b4baf3a506cc3d3ed71bcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_progress_handler </td>
          <td>(</td>
          <td class="paramtype">progress_handler&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a callback function that will be invoked for every chunk of data uploaded or downloaded as part of the request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A function representing the progress handler. It's parameters are: up: a <code>message_direction::direction</code> value indicating the direction of the message that is being reported. progress: the number of bytes that have been processed so far. </td></tr>
  </table>
  </dd>
</dl>
<p><b>EXPERIMENTAL</b> This function is subject to change based on user feedback.</p>
<p>This function will be called at least once for upload and at least once for the download body, unless there is some exception generated. An HTTP message with an error code is not an exception. This means, that even if there is no body, the progress handler will be called.</p>
<p>Setting the chunk size on the http_client does not guarantee that the client will be using exactly that increment for uploading and downloading data.</p>
<p>The handler will be called only once for each combination of argument values, in order. Depending on how a service responds, some download values may come before all upload values have been reported.</p>
<p>The progress handler will be called on the thread processing the request. This means that the implementation of the handler must take care not to block the thread or do anything that takes significant amounts of time. In particular, do not do any kind of I/O from within the handler, do not update user interfaces, and to not acquire any locks. If such activities are necessary, it is the handler's responsibilty to execute that work on a separate thread. </p>

</div>
</div>
<a class="anchor" id="acea3e29c7c8665d35608fc4d51b9a3bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_request_uri </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1uri.html">uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the underling URI of the request message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The uri for this message.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3fa7e9676489687b10390ead50540fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_response_stream </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::ostream&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to hold the body of the HTTP response message that results from the request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A writable, open asynchronous stream.</td></tr>
  </table>
  </dd>
</dl>
<p>If this function is called, the body of the response should not be accessed in any other way. </p>

</div>
</div>
<a class="anchor" id="a1e95dcdd5f609db1fd4d4ff2dfe4c5d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">utility::string_t web::http::http_request::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string representation of the message, including the body when possible. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representation of this HTTP request.</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cpprest/<a class="el" href="http__msg_8h_source.html">http_msg.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 19 2014 16:17:55 for C++ Rest SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
