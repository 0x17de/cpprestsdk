<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>C++ Rest SDK: web::http::http_request Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cloud.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Rest SDK
   </div>
   <div id="projectbrief">The C++ REST SDK is a Microsoft project for cloud-based client-server communication in native code using a modern asynchronous C++ API design. This project aims to help C++ developers connect to and interact with services.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceweb.html">web</a></li><li class="navelem"><a class="el" href="namespaceweb_1_1http.html">http</a></li><li class="navelem"><a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classweb_1_1http_1_1http__request-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">web::http::http_request Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents an HTTP request.  
 <a href="classweb_1_1http_1_1http__request.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="http__msg_8h_source.html">http_msg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d7c632f0de4ba389a5218bc071033c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a6d7c632f0de4ba389a5218bc071033c1">http_request</a> ()</td></tr>
<tr class="memdesc:a6d7c632f0de4ba389a5218bc071033c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new HTTP request with the 'GET' method.  <a href="#a6d7c632f0de4ba389a5218bc071033c1">More...</a><br /></td></tr>
<tr class="separator:a6d7c632f0de4ba389a5218bc071033c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2100f0d3d854550c94acae88a2ba46c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a2100f0d3d854550c94acae88a2ba46c5">http_request</a> (<a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a> mtd)</td></tr>
<tr class="memdesc:a2100f0d3d854550c94acae88a2ba46c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new HTTP request with the given request method.  <a href="#a2100f0d3d854550c94acae88a2ba46c5">More...</a><br /></td></tr>
<tr class="separator:a2100f0d3d854550c94acae88a2ba46c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468dbac9f4ebeeda55308a73f1ccc483"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a468dbac9f4ebeeda55308a73f1ccc483">~http_request</a> ()</td></tr>
<tr class="memdesc:a468dbac9f4ebeeda55308a73f1ccc483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor frees any held resources.  <a href="#a468dbac9f4ebeeda55308a73f1ccc483">More...</a><br /></td></tr>
<tr class="separator:a468dbac9f4ebeeda55308a73f1ccc483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9067f56e50c7de2130d57c2b3d19e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a6a9067f56e50c7de2130d57c2b3d19e4">method</a> () const </td></tr>
<tr class="memdesc:a6a9067f56e50c7de2130d57c2b3d19e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the method (GET/PUT/POST/DELETE) of the request message.  <a href="#a6a9067f56e50c7de2130d57c2b3d19e4">More...</a><br /></td></tr>
<tr class="separator:a6a9067f56e50c7de2130d57c2b3d19e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa00491ba45afcca6e988acdfe0434b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#afa00491ba45afcca6e988acdfe0434b4">set_method</a> (const <a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a> &amp;<a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">method</a>) const </td></tr>
<tr class="memdesc:afa00491ba45afcca6e988acdfe0434b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the method (GET/PUT/POST/DELETE) of the request message.  <a href="#afa00491ba45afcca6e988acdfe0434b4">More...</a><br /></td></tr>
<tr class="separator:afa00491ba45afcca6e988acdfe0434b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e06374ab1a6fac827d50005c1d6a13"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classweb_1_1uri.html">uri</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a18e06374ab1a6fac827d50005c1d6a13">request_uri</a> () const </td></tr>
<tr class="memdesc:a18e06374ab1a6fac827d50005c1d6a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underling URI of the request message.  <a href="#a18e06374ab1a6fac827d50005c1d6a13">More...</a><br /></td></tr>
<tr class="separator:a18e06374ab1a6fac827d50005c1d6a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea3e29c7c8665d35608fc4d51b9a3bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#acea3e29c7c8665d35608fc4d51b9a3bb">set_request_uri</a> (const <a class="el" href="classweb_1_1uri.html">uri</a> &amp;<a class="el" href="classweb_1_1uri.html">uri</a>)</td></tr>
<tr class="memdesc:acea3e29c7c8665d35608fc4d51b9a3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the underling URI of the request message.  <a href="#acea3e29c7c8665d35608fc4d51b9a3bb">More...</a><br /></td></tr>
<tr class="separator:acea3e29c7c8665d35608fc4d51b9a3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8aad665e1c0309ec3f788a4dfc9f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1uri.html">uri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a5f8aad665e1c0309ec3f788a4dfc9f05">relative_uri</a> () const </td></tr>
<tr class="memdesc:a5f8aad665e1c0309ec3f788a4dfc9f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference the URI path, query, and fragment part of this request message. This will be appended to the base URI specified at construction of the http_client.  <a href="#a5f8aad665e1c0309ec3f788a4dfc9f05">More...</a><br /></td></tr>
<tr class="separator:a5f8aad665e1c0309ec3f788a4dfc9f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f8bb329f6a0c9c3131182983d49390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1uri.html">uri</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a52f8bb329f6a0c9c3131182983d49390">absolute_uri</a> () const </td></tr>
<tr class="memdesc:a52f8bb329f6a0c9c3131182983d49390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an absolute URI with scheme, host, port, path, query, and fragment part of the request message.  <a href="#a52f8bb329f6a0c9c3131182983d49390">More...</a><br /></td></tr>
<tr class="separator:a52f8bb329f6a0c9c3131182983d49390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a7501be1b05d8361622b877f2bae5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ad1a7501be1b05d8361622b877f2bae5c">headers</a> ()</td></tr>
<tr class="memdesc:ad1a7501be1b05d8361622b877f2bae5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the headers of the response message.  <a href="#ad1a7501be1b05d8361622b877f2bae5c">More...</a><br /></td></tr>
<tr class="separator:ad1a7501be1b05d8361622b877f2bae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54168ed27f3080ea73335b0f397022b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a54168ed27f3080ea73335b0f397022b5">headers</a> () const </td></tr>
<tr class="memdesc:a54168ed27f3080ea73335b0f397022b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a const reference to the headers of the response message.  <a href="#a54168ed27f3080ea73335b0f397022b5">More...</a><br /></td></tr>
<tr class="separator:a54168ed27f3080ea73335b0f397022b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd0f1c49cab39210517925a3644db1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a0cd0f1c49cab39210517925a3644db1f">extract_string</a> (bool ignore_content_type=false)</td></tr>
<tr class="memdesc:a0cd0f1c49cab39210517925a3644db1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the body of the request message as a string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#a0cd0f1c49cab39210517925a3644db1f">More...</a><br /></td></tr>
<tr class="separator:a0cd0f1c49cab39210517925a3644db1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38a00ce543ac6e7a27dfbb164bbebe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; utf8string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ac38a00ce543ac6e7a27dfbb164bbebe4">extract_utf8string</a> (bool ignore_content_type=false)</td></tr>
<tr class="memdesc:ac38a00ce543ac6e7a27dfbb164bbebe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the body of the request message as a UTF-8 string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#ac38a00ce543ac6e7a27dfbb164bbebe4">More...</a><br /></td></tr>
<tr class="separator:ac38a00ce543ac6e7a27dfbb164bbebe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3befbd7c8d0a1c9b135d9f8f34a5281f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; utf16string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a3befbd7c8d0a1c9b135d9f8f34a5281f">extract_utf16string</a> (bool ignore_content_type=false)</td></tr>
<tr class="memdesc:a3befbd7c8d0a1c9b135d9f8f34a5281f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the body of the request message as a UTF-16 string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#a3befbd7c8d0a1c9b135d9f8f34a5281f">More...</a><br /></td></tr>
<tr class="separator:a3befbd7c8d0a1c9b135d9f8f34a5281f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c3d7532fe943de75dcc0445456cbc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ae6c3d7532fe943de75dcc0445456cbc7">extract_json</a> (bool ignore_content_type=false) const </td></tr>
<tr class="memdesc:ae6c3d7532fe943de75dcc0445456cbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the request message into a json value, checking that the content type is application/json. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#ae6c3d7532fe943de75dcc0445456cbc7">More...</a><br /></td></tr>
<tr class="separator:ae6c3d7532fe943de75dcc0445456cbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af328f088cb412491d4ad05fec7ecd964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; std::vector&lt; unsigned char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#af328f088cb412491d4ad05fec7ecd964">extract_vector</a> () const </td></tr>
<tr class="memdesc:af328f088cb412491d4ad05fec7ecd964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the body of the response message into a vector of bytes. Extracting a vector can be done on  <a href="#af328f088cb412491d4ad05fec7ecd964">More...</a><br /></td></tr>
<tr class="separator:af328f088cb412491d4ad05fec7ecd964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb84af37dff1025e18b5c7f6d326bff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a7bb84af37dff1025e18b5c7f6d326bff">set_body</a> (utf8string &amp;&amp;body_text, const utf8string &amp;content_type=utf8string(&quot;text/plain; charset=utf-8&quot;))</td></tr>
<tr class="memdesc:a7bb84af37dff1025e18b5c7f6d326bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-8.  <a href="#a7bb84af37dff1025e18b5c7f6d326bff">More...</a><br /></td></tr>
<tr class="separator:a7bb84af37dff1025e18b5c7f6d326bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c74132fbe2df7c5b0982c17e4e85e19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a2c74132fbe2df7c5b0982c17e4e85e19">set_body</a> (const utf8string &amp;body_text, const utf8string &amp;content_type=utf8string(&quot;text/plain; charset=utf-8&quot;))</td></tr>
<tr class="memdesc:a2c74132fbe2df7c5b0982c17e4e85e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-8.  <a href="#a2c74132fbe2df7c5b0982c17e4e85e19">More...</a><br /></td></tr>
<tr class="separator:a2c74132fbe2df7c5b0982c17e4e85e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31034edca1a1ffac63fb7d566a407070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a31034edca1a1ffac63fb7d566a407070">set_body</a> (const utf16string &amp;body_text, utf16string content_type=::<a class="el" href="namespaceutility_1_1conversions.html#ac56351f05efb283401aac4249b816894">utility::conversions::to_utf16string</a>(&quot;text/plain&quot;))</td></tr>
<tr class="memdesc:a31034edca1a1ffac63fb7d566a407070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-16 will perform conversion to UTF-8.  <a href="#a31034edca1a1ffac63fb7d566a407070">More...</a><br /></td></tr>
<tr class="separator:a31034edca1a1ffac63fb7d566a407070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af947ade6138106cb424c68b8bed9d641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#af947ade6138106cb424c68b8bed9d641">set_body</a> (const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;body_data)</td></tr>
<tr class="memdesc:af947ade6138106cb424c68b8bed9d641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to contain json value. If the 'Content-Type' header hasn't already been set it will be set to 'application/json'.  <a href="#af947ade6138106cb424c68b8bed9d641">More...</a><br /></td></tr>
<tr class="separator:af947ade6138106cb424c68b8bed9d641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cf25f7f0180a3e5838f38e8de660ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a26cf25f7f0180a3e5838f38e8de660ee">set_body</a> (std::vector&lt; unsigned char &gt; &amp;&amp;body_data)</td></tr>
<tr class="memdesc:a26cf25f7f0180a3e5838f38e8de660ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'.  <a href="#a26cf25f7f0180a3e5838f38e8de660ee">More...</a><br /></td></tr>
<tr class="separator:a26cf25f7f0180a3e5838f38e8de660ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300fb45fe64b5e91f061b607c3877d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a300fb45fe64b5e91f061b607c3877d16">set_body</a> (const std::vector&lt; unsigned char &gt; &amp;body_data)</td></tr>
<tr class="memdesc:a300fb45fe64b5e91f061b607c3877d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'.  <a href="#a300fb45fe64b5e91f061b607c3877d16">More...</a><br /></td></tr>
<tr class="separator:a300fb45fe64b5e91f061b607c3877d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d6cc0210ff53e18e46e5591ce355ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a05d6cc0210ff53e18e46e5591ce355ab">set_body</a> (const concurrency::streams::istream &amp;stream, const utility::string_t &amp;content_type=_XPLATSTR(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:a05d6cc0210ff53e18e46e5591ce355ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to provide the body of the HTTP message when it is sent.  <a href="#a05d6cc0210ff53e18e46e5591ce355ab">More...</a><br /></td></tr>
<tr class="separator:a05d6cc0210ff53e18e46e5591ce355ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f89a02afcb62a8f11dbf955b40410f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a0f89a02afcb62a8f11dbf955b40410f2">set_body</a> (const concurrency::streams::istream &amp;stream, utility::size64_t content_length, const utility::string_t &amp;content_type=_XPLATSTR(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:a0f89a02afcb62a8f11dbf955b40410f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to provide the body of the HTTP message when it is sent.  <a href="#a0f89a02afcb62a8f11dbf955b40410f2">More...</a><br /></td></tr>
<tr class="separator:a0f89a02afcb62a8f11dbf955b40410f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b6309dc6c704aab674d9afcbb3fa01"><td class="memItemLeft" align="right" valign="top">concurrency::streams::istream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ac7b6309dc6c704aab674d9afcbb3fa01">body</a> () const </td></tr>
<tr class="memdesc:ac7b6309dc6c704aab674d9afcbb3fa01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a stream which the caller may use to retrieve data from an incoming request.  <a href="#ac7b6309dc6c704aab674d9afcbb3fa01">More...</a><br /></td></tr>
<tr class="separator:ac7b6309dc6c704aab674d9afcbb3fa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38790c35476ea1214473d2fc6ed55c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ae38790c35476ea1214473d2fc6ed55c9">set_response_stream</a> (const concurrency::streams::ostream &amp;stream)</td></tr>
<tr class="memdesc:ae38790c35476ea1214473d2fc6ed55c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to hold the body of the HTTP response message that results from the request.  <a href="#ae38790c35476ea1214473d2fc6ed55c9">More...</a><br /></td></tr>
<tr class="separator:ae38790c35476ea1214473d2fc6ed55c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb8ba4c46ba84f8135e8e95103c3cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#aecb8ba4c46ba84f8135e8e95103c3cea">set_progress_handler</a> (const progress_handler &amp;handler)</td></tr>
<tr class="memdesc:aecb8ba4c46ba84f8135e8e95103c3cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a callback function that will be invoked for every chunk of data uploaded or downloaded as part of the request.  <a href="#aecb8ba4c46ba84f8135e8e95103c3cea">More...</a><br /></td></tr>
<tr class="separator:aecb8ba4c46ba84f8135e8e95103c3cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34a0f0f1f1b43df856df2ea1f9273be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#af34a0f0f1f1b43df856df2ea1f9273be">reply</a> (const <a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> &amp;response) const </td></tr>
<tr class="memdesc:af34a0f0f1f1b43df856df2ea1f9273be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously responses to this HTTP request.  <a href="#af34a0f0f1f1b43df856df2ea1f9273be">More...</a><br /></td></tr>
<tr class="separator:af34a0f0f1f1b43df856df2ea1f9273be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1e5817410850b06abde2b712b6ebce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a7d1e5817410850b06abde2b712b6ebce">reply</a> (http::status_code status) const </td></tr>
<tr class="memdesc:a7d1e5817410850b06abde2b712b6ebce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously responses to this HTTP request.  <a href="#a7d1e5817410850b06abde2b712b6ebce">More...</a><br /></td></tr>
<tr class="separator:a7d1e5817410850b06abde2b712b6ebce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d1463151d1b65f150ae03b2dca447f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a31d1463151d1b65f150ae03b2dca447f">reply</a> (http::status_code status, const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;body_data) const </td></tr>
<tr class="memdesc:a31d1463151d1b65f150ae03b2dca447f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responds to this HTTP request.  <a href="#a31d1463151d1b65f150ae03b2dca447f">More...</a><br /></td></tr>
<tr class="separator:a31d1463151d1b65f150ae03b2dca447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753f87b84155a3adf78080edccdca6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a753f87b84155a3adf78080edccdca6b5">reply</a> (http::status_code status, utf8string &amp;&amp;body_data, const utf8string &amp;content_type=&quot;text/plain; charset=utf-8&quot;) const </td></tr>
<tr class="separator:a753f87b84155a3adf78080edccdca6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71b807d0263ed2a3b5838b6bfa30437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ae71b807d0263ed2a3b5838b6bfa30437">reply</a> (http::status_code status, const utf8string &amp;body_data, const utf8string &amp;content_type=&quot;text/plain; charset=utf-8&quot;) const </td></tr>
<tr class="memdesc:ae71b807d0263ed2a3b5838b6bfa30437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responds to this HTTP request with a string. Assumes the character encoding of the string is UTF-8.  <a href="#ae71b807d0263ed2a3b5838b6bfa30437">More...</a><br /></td></tr>
<tr class="separator:ae71b807d0263ed2a3b5838b6bfa30437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afb8ae0a99bdce9518059fadfbcb081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a7afb8ae0a99bdce9518059fadfbcb081">reply</a> (http::status_code status, const utf16string &amp;body_data, const utf16string &amp;content_type=::<a class="el" href="namespaceutility_1_1conversions.html#ac56351f05efb283401aac4249b816894">utility::conversions::to_utf16string</a>(&quot;text/plain&quot;)) const </td></tr>
<tr class="memdesc:a7afb8ae0a99bdce9518059fadfbcb081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responds to this HTTP request with a string. Assumes the character encoding of the string is UTF-16 will perform conversion to UTF-8.  <a href="#a7afb8ae0a99bdce9518059fadfbcb081">More...</a><br /></td></tr>
<tr class="separator:a7afb8ae0a99bdce9518059fadfbcb081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7862122bf6f08c40b2a04f02696295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a4d7862122bf6f08c40b2a04f02696295">reply</a> (status_code status, const concurrency::streams::istream &amp;<a class="el" href="classweb_1_1http_1_1http__request.html#ac7b6309dc6c704aab674d9afcbb3fa01">body</a>, const utility::string_t &amp;content_type=_XPLATSTR(&quot;application/octet-stream&quot;)) const </td></tr>
<tr class="memdesc:a4d7862122bf6f08c40b2a04f02696295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responds to this HTTP request.  <a href="#a4d7862122bf6f08c40b2a04f02696295">More...</a><br /></td></tr>
<tr class="separator:a4d7862122bf6f08c40b2a04f02696295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1030ce7dbb58a6deb801eebd2e3eec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#acb1030ce7dbb58a6deb801eebd2e3eec">reply</a> (status_code status, const concurrency::streams::istream &amp;<a class="el" href="classweb_1_1http_1_1http__request.html#ac7b6309dc6c704aab674d9afcbb3fa01">body</a>, utility::size64_t content_length, const utility::string_t &amp;content_type=_XPLATSTR(&quot;application/octet-stream&quot;)) const </td></tr>
<tr class="memdesc:acb1030ce7dbb58a6deb801eebd2e3eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responds to this HTTP request.  <a href="#acb1030ce7dbb58a6deb801eebd2e3eec">More...</a><br /></td></tr>
<tr class="separator:acb1030ce7dbb58a6deb801eebd2e3eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a2b663915b4a39c715b09fd8c1df3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a71a2b663915b4a39c715b09fd8c1df3a">content_ready</a> () const </td></tr>
<tr class="memdesc:a71a2b663915b4a39c715b09fd8c1df3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the user (listener) when all the data for this request message has been received.  <a href="#a71a2b663915b4a39c715b09fd8c1df3a">More...</a><br /></td></tr>
<tr class="separator:a71a2b663915b4a39c715b09fd8c1df3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b676982783b8bc89335e5855943c0e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a6b676982783b8bc89335e5855943c0e7">get_response</a> () const </td></tr>
<tr class="memdesc:a6b676982783b8bc89335e5855943c0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a task representing the response that will eventually be sent.  <a href="#a6b676982783b8bc89335e5855943c0e7">More...</a><br /></td></tr>
<tr class="separator:a6b676982783b8bc89335e5855943c0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e95dcdd5f609db1fd4d4ff2dfe4c5d3"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a1e95dcdd5f609db1fd4d4ff2dfe4c5d3">to_string</a> () const </td></tr>
<tr class="memdesc:a1e95dcdd5f609db1fd4d4ff2dfe4c5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string representation of the message, including the body when possible. Mainly this should be used for debugging purposes as it has to copy the message body and doesn't have excellent performance.  <a href="#a1e95dcdd5f609db1fd4d4ff2dfe4c5d3">More...</a><br /></td></tr>
<tr class="separator:a1e95dcdd5f609db1fd4d4ff2dfe4c5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0c3f7ca3c0289f036e7d2005802012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#a6c0c3f7ca3c0289f036e7d2005802012">_reply_if_not_already</a> (status_code status)</td></tr>
<tr class="memdesc:a6c0c3f7ca3c0289f036e7d2005802012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a response if one has not already been sent.  <a href="#a6c0c3f7ca3c0289f036e7d2005802012">More...</a><br /></td></tr>
<tr class="separator:a6c0c3f7ca3c0289f036e7d2005802012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebed833f56554d7ac508dd5ab5224bb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1http_1_1details_1_1__http__server__context.html">http::details::_http_server_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#aebed833f56554d7ac508dd5ab5224bb2">_get_server_context</a> () const </td></tr>
<tr class="memdesc:aebed833f56554d7ac508dd5ab5224bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the server context associated with this HTTP message.  <a href="#aebed833f56554d7ac508dd5ab5224bb2">More...</a><br /></td></tr>
<tr class="separator:aebed833f56554d7ac508dd5ab5224bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d08d1ce0ba9a09ea8b20d8219e22be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49d08d1ce0ba9a09ea8b20d8219e22be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_set_server_context</b> (std::unique_ptr&lt; <a class="el" href="classweb_1_1http_1_1details_1_1__http__server__context.html">http::details::_http_server_context</a> &gt; server_context)</td></tr>
<tr class="separator:a49d08d1ce0ba9a09ea8b20d8219e22be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcc8bd36d2eba369d6e56a12b8d9492"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bcc8bd36d2eba369d6e56a12b8d9492"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_set_listener_path</b> (const utility::string_t &amp;path)</td></tr>
<tr class="separator:a9bcc8bd36d2eba369d6e56a12b8d9492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd27b9951fd0ef891db0e77e789c80a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd27b9951fd0ef891db0e77e789c80a3"></a>
const std::shared_ptr&lt; <a class="el" href="classweb_1_1http_1_1details_1_1__http__request.html">http::details::_http_request</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_get_impl</b> () const </td></tr>
<tr class="separator:acd27b9951fd0ef891db0e77e789c80a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b915ec057daf47cbda4dea9822ee9fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b915ec057daf47cbda4dea9822ee9fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_set_cancellation_token</b> (const <a class="el" href="classpplx_1_1cancellation__token.html">pplx::cancellation_token</a> &amp;token)</td></tr>
<tr class="separator:a1b915ec057daf47cbda4dea9822ee9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14b0f0458205749e6e506e0360c0973"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac14b0f0458205749e6e506e0360c0973"></a>
const <a class="el" href="classpplx_1_1cancellation__token.html">pplx::cancellation_token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_cancellation_token</b> () const </td></tr>
<tr class="separator:ac14b0f0458205749e6e506e0360c0973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be8efa02b4cb25ef0277cf93742a49e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1be8efa02b4cb25ef0277cf93742a49e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_set_base_uri</b> (const <a class="el" href="classweb_1_1uri.html">http::uri</a> &amp;base_uri)</td></tr>
<tr class="separator:a1be8efa02b4cb25ef0277cf93742a49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab71c6bb901c58736a732a05ec0aff4e7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__request.html#ab71c6bb901c58736a732a05ec0aff4e7">_create_request</a> (std::unique_ptr&lt; <a class="el" href="classweb_1_1http_1_1details_1_1__http__server__context.html">http::details::_http_server_context</a> &gt; server_context)</td></tr>
<tr class="memdesc:ab71c6bb901c58736a732a05ec0aff4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are used for the initial creation of the HTTP request.  <a href="#ab71c6bb901c58736a732a05ec0aff4e7">More...</a><br /></td></tr>
<tr class="separator:ab71c6bb901c58736a732a05ec0aff4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a11cef17538a5dc100fd2405ca61f503b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11cef17538a5dc100fd2405ca61f503b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>http::details::_http_request</b></td></tr>
<tr class="separator:a11cef17538a5dc100fd2405ca61f503b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba89159a8d6a4bc47e5d2c54ff9debc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abba89159a8d6a4bc47e5d2c54ff9debc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>http::client::http_client</b></td></tr>
<tr class="separator:abba89159a8d6a4bc47e5d2c54ff9debc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an HTTP request. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6d7c632f0de4ba389a5218bc071033c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_request::http_request </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new HTTP request with the 'GET' method. </p>

</div>
</div>
<a class="anchor" id="a2100f0d3d854550c94acae88a2ba46c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_request::http_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a>&#160;</td>
          <td class="paramname"><em>mtd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new HTTP request with the given request method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtd</td><td>Request method.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a468dbac9f4ebeeda55308a73f1ccc483"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_request::~http_request </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor frees any held resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab71c6bb901c58736a732a05ec0aff4e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a> web::http::http_request::_create_request </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classweb_1_1http_1_1details_1_1__http__server__context.html">http::details::_http_server_context</a> &gt;&#160;</td>
          <td class="paramname"><em>server_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are used for the initial creation of the HTTP request. </p>

</div>
</div>
<a class="anchor" id="aebed833f56554d7ac508dd5ab5224bb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1http_1_1details_1_1__http__server__context.html">http::details::_http_server_context</a>* web::http::http_request::_get_server_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the server context associated with this HTTP message. </p>

</div>
</div>
<a class="anchor" id="a6c0c3f7ca3c0289f036e7d2005802012"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::_reply_if_not_already </td>
          <td>(</td>
          <td class="paramtype">status_code&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a response if one has not already been sent. </p>

</div>
</div>
<a class="anchor" id="a52f8bb329f6a0c9c3131182983d49390"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1uri.html">uri</a> web::http::http_request::absolute_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an absolute URI with scheme, host, port, path, query, and fragment part of the request message. </p>
<p>Absolute URI is only valid after this <a class="el" href="classweb_1_1http_1_1http__request.html" title="Represents an HTTP request. ">http_request</a> object has been passed to http_client::request(). </p>

</div>
</div>
<a class="anchor" id="ac7b6309dc6c704aab674d9afcbb3fa01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">concurrency::streams::istream web::http::http_request::body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces a stream which the caller may use to retrieve data from an incoming request. </p>
<dl class="section return"><dt>Returns</dt><dd>A readable, open asynchronous stream.</dd></dl>
<p>This cannot be used in conjunction with any other means of getting the body of the request. It is not necessary to wait until the message has been sent before starting to write to the stream, but it is advisable to do so, since it will allow the network I/O to start earlier and the work of sending data can be overlapped with the production of more data. </p>

</div>
</div>
<a class="anchor" id="a71a2b663915b4a39c715b09fd8c1df3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1http_1_1http__request.html">http_request</a>&gt; web::http::http_request::content_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals the user (listener) when all the data for this request message has been received. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> which is completed when all of the response body has been received</dd></dl>

</div>
</div>
<a class="anchor" id="ae6c3d7532fe943de75dcc0445456cbc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1json_1_1value.html">json::value</a>&gt; web::http::http_request::extract_json </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_content_type</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the request message into a json value, checking that the content type is application/json. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_content_type</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON value from the body of this message.</dd></dl>

</div>
</div>
<a class="anchor" id="a0cd0f1c49cab39210517925a3644db1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;utility::string_t&gt; web::http::http_request::extract_string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_content_type</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the body of the request message as a string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_content_type</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing body of the message.</dd></dl>

</div>
</div>
<a class="anchor" id="a3befbd7c8d0a1c9b135d9f8f34a5281f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;utf16string&gt; web::http::http_request::extract_utf16string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_content_type</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the body of the request message as a UTF-16 string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_content_type</td><td>If true, ignores the Content-Type header and assumes UTF-16.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing body of the message.</dd></dl>

</div>
</div>
<a class="anchor" id="ac38a00ce543ac6e7a27dfbb164bbebe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;utf8string&gt; web::http::http_request::extract_utf8string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_content_type</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the body of the request message as a UTF-8 string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_content_type</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing body of the message.</dd></dl>

</div>
</div>
<a class="anchor" id="af328f088cb412491d4ad05fec7ecd964"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;std::vector&lt;unsigned char&gt; &gt; web::http::http_request::extract_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the body of the response message into a vector of bytes. Extracting a vector can be done on </p>
<dl class="section return"><dt>Returns</dt><dd>The body of the message as a vector of bytes.</dd></dl>

</div>
</div>
<a class="anchor" id="a6b676982783b8bc89335e5855943c0e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a>&gt; web::http::http_request::get_response </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a task representing the response that will eventually be sent. </p>
<dl class="section return"><dt>Returns</dt><dd>A task that is completed once response is sent.</dd></dl>

</div>
</div>
<a class="anchor" id="ad1a7501be1b05d8361622b877f2bae5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a>&amp; web::http::http_request::headers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference to the headers of the response message. </p>
<dl class="section return"><dt>Returns</dt><dd>HTTP headers for this response.</dd></dl>
<p>Use the <a class="el" href="classweb_1_1http_1_1http__headers.html#aae02146934ff5ad3f7a45307f2ab2660" title="Adds a header field using the &#39;<<&#39; operator. ">http_headers::add</a> to fill in desired headers. </p>

</div>
</div>
<a class="anchor" id="a54168ed27f3080ea73335b0f397022b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a>&amp; web::http::http_request::headers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a const reference to the headers of the response message. </p>
<dl class="section return"><dt>Returns</dt><dd>HTTP headers for this response.</dd></dl>
<p>Use the <a class="el" href="classweb_1_1http_1_1http__headers.html#aae02146934ff5ad3f7a45307f2ab2660" title="Adds a header field using the &#39;<<&#39; operator. ">http_headers::add</a> to fill in desired headers. </p>

</div>
</div>
<a class="anchor" id="a6a9067f56e50c7de2130d57c2b3d19e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a>&amp; web::http::http_request::method </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the method (GET/PUT/POST/DELETE) of the request message. </p>
<dl class="section return"><dt>Returns</dt><dd>Request method of this HTTP request.</dd></dl>

</div>
</div>
<a class="anchor" id="a5f8aad665e1c0309ec3f788a4dfc9f05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1uri.html">uri</a> web::http::http_request::relative_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a reference the URI path, query, and fragment part of this request message. This will be appended to the base URI specified at construction of the http_client. </p>
<dl class="section return"><dt>Returns</dt><dd>A string.</dd></dl>
<p>When the request is the one passed to a listener's handler, the relative URI is the request URI less the listener's path. In all other circumstances, <a class="el" href="classweb_1_1http_1_1http__request.html#a18e06374ab1a6fac827d50005c1d6a13" title="Get the underling URI of the request message. ">request_uri()</a> and <a class="el" href="classweb_1_1http_1_1http__request.html#a5f8aad665e1c0309ec3f788a4dfc9f05" title="Gets a reference the URI path, query, and fragment part of this request message. This will be appende...">relative_uri()</a> will return the same value. </p>

</div>
</div>
<a class="anchor" id="af34a0f0f1f1b43df856df2ea1f9273be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously responses to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">response</td><td>Response to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>

</div>
</div>
<a class="anchor" id="a7d1e5817410850b06abde2b712b6ebce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously responses to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>

</div>
</div>
<a class="anchor" id="a31d1463151d1b65f150ae03b2dca447f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;&#160;</td>
          <td class="paramname"><em>body_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responds to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">body_data</td><td>Json value to use in the response body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>

</div>
</div>
<a class="anchor" id="a753f87b84155a3adf78080edccdca6b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utf8string &amp;&amp;&#160;</td>
          <td class="paramname"><em>body_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utf8string &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>&quot;text/plain;&#160;charset=utf-8&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Responds to this HTTP request with a string. Assumes the character encoding of the string is UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">body_data</td><td>UTF-8 string containing the text to use in the response body.</td></tr>
    <tr><td class="paramname">content_type</td><td>Content type of the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>
<p>sent to before the body data is destroyed or goes out of scope. </p>

</div>
</div>
<a class="anchor" id="ae71b807d0263ed2a3b5838b6bfa30437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utf8string &amp;&#160;</td>
          <td class="paramname"><em>body_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utf8string &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>&quot;text/plain;&#160;charset=utf-8&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responds to this HTTP request with a string. Assumes the character encoding of the string is UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">body_data</td><td>UTF-8 string containing the text to use in the response body.</td></tr>
    <tr><td class="paramname">content_type</td><td>Content type of the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>
<p>sent to before the body data is destroyed or goes out of scope. </p>

</div>
</div>
<a class="anchor" id="a7afb8ae0a99bdce9518059fadfbcb081"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utf16string &amp;&#160;</td>
          <td class="paramname"><em>body_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utf16string &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>::<a class="el" href="namespaceutility_1_1conversions.html#ac56351f05efb283401aac4249b816894">utility::conversions::to_utf16string</a>(&quot;text/plain&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responds to this HTTP request with a string. Assumes the character encoding of the string is UTF-16 will perform conversion to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">body_data</td><td>UTF-16 string containing the text to use in the response body.</td></tr>
    <tr><td class="paramname">content_type</td><td>Content type of the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An asynchronous operation that is completed once response is sent.</dd></dl>
<p>sent to before the body data is destroyed or goes out of scope. </p>

</div>
</div>
<a class="anchor" id="a4d7862122bf6f08c40b2a04f02696295"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const concurrency::streams::istream &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responds to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
    <tr><td class="paramname">body</td><td>An asynchronous stream representing the body data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A task that is completed once a response from the request is received.</dd></dl>

</div>
</div>
<a class="anchor" id="acb1030ce7dbb58a6deb801eebd2e3eec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; web::http::http_request::reply </td>
          <td>(</td>
          <td class="paramtype">status_code&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const concurrency::streams::istream &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>content_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Responds to this HTTP request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Response status code.</td></tr>
    <tr><td class="paramname">content_length</td><td>The size of the data to be sent in the body..</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
    <tr><td class="paramname">body</td><td>An asynchronous stream representing the body data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A task that is completed once a response from the request is received.</dd></dl>

</div>
</div>
<a class="anchor" id="a18e06374ab1a6fac827d50005c1d6a13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classweb_1_1uri.html">uri</a>&amp; web::http::http_request::request_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the underling URI of the request message. </p>
<dl class="section return"><dt>Returns</dt><dd>The uri of this message.</dd></dl>

</div>
</div>
<a class="anchor" id="a7bb84af37dff1025e18b5c7f6d326bff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">utf8string &amp;&amp;&#160;</td>
          <td class="paramname"><em>body_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utf8string &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>utf8string(&quot;text/plain;&#160;charset=utf-8&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>String containing body text.</td></tr>
    <tr><td class="paramname">content_type</td><td>MIME type to set the "Content-Type" header to. Default to "text/plain; charset=utf-8".</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data and "Content-Type" header. </p>

</div>
</div>
<a class="anchor" id="a2c74132fbe2df7c5b0982c17e4e85e19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">const utf8string &amp;&#160;</td>
          <td class="paramname"><em>body_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utf8string &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>utf8string(&quot;text/plain;&#160;charset=utf-8&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>String containing body text.</td></tr>
    <tr><td class="paramname">content_type</td><td>MIME type to set the "Content-Type" header to. Default to "text/plain; charset=utf-8".</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data and "Content-Type" header. </p>

</div>
</div>
<a class="anchor" id="a31034edca1a1ffac63fb7d566a407070"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">const utf16string &amp;&#160;</td>
          <td class="paramname"><em>body_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utf16string&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>::<a class="el" href="namespaceutility_1_1conversions.html#ac56351f05efb283401aac4249b816894">utility::conversions::to_utf16string</a>(&quot;text/plain&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-16 will perform conversion to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>String containing body text.</td></tr>
    <tr><td class="paramname">content_type</td><td>MIME type to set the "Content-Type" header to. Default to "text/plain".</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data and "Content-Type" header. </p>

</div>
</div>
<a class="anchor" id="af947ade6138106cb424c68b8bed9d641"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to contain json value. If the 'Content-Type' header hasn't already been set it will be set to 'application/json'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_data</td><td>json value.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="a26cf25f7f0180a3e5838f38e8de660ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_data</td><td>Vector containing body data.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="a300fb45fe64b5e91f061b607c3877d16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_data</td><td>Vector containing body data.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="a05d6cc0210ff53e18e46e5591ce355ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">const concurrency::streams::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to provide the body of the HTTP message when it is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A readable, open asynchronous stream.</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
  </table>
  </dd>
</dl>
<p>This cannot be used in conjunction with any other means of setting the body of the request. The stream will not be read until the message is sent. </p>

</div>
</div>
<a class="anchor" id="a0f89a02afcb62a8f11dbf955b40410f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_body </td>
          <td>(</td>
          <td class="paramtype">const concurrency::streams::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>content_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to provide the body of the HTTP message when it is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A readable, open asynchronous stream.</td></tr>
    <tr><td class="paramname">content_length</td><td>The size of the data to be sent in the body.</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
  </table>
  </dd>
</dl>
<p>This cannot be used in conjunction with any other means of setting the body of the request. The stream will not be read until the message is sent. </p>

</div>
</div>
<a class="anchor" id="afa00491ba45afcca6e988acdfe0434b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceweb_1_1http.html#a10753d257365e0864768e18dd985e82a">http::method</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the method (GET/PUT/POST/DELETE) of the request message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>Request method of this HTTP request.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecb8ba4c46ba84f8135e8e95103c3cea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_progress_handler </td>
          <td>(</td>
          <td class="paramtype">const progress_handler &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a callback function that will be invoked for every chunk of data uploaded or downloaded as part of the request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A function representing the progress handler. It's parameters are: up: a <code><a class="el" href="namespaceweb_1_1http_1_1message__direction.html#a447bc1591a2929db97f0f9513a2ad175" title="Enumeration used to denote the direction of a message: a request with a body is an upload...">message_direction::direction</a></code> value indicating the direction of the message that is being reported. progress: the number of bytes that have been processed so far. </td></tr>
  </table>
  </dd>
</dl>
<p>This function will be called at least once for upload and at least once for the download body, unless there is some exception generated. An HTTP message with an error code is not an exception. This means, that even if there is no body, the progress handler will be called.</p>
<p>Setting the chunk size on the http_client does not guarantee that the client will be using exactly that increment for uploading and downloading data.</p>
<p>The handler will be called only once for each combination of argument values, in order. Depending on how a service responds, some download values may come before all upload values have been reported.</p>
<p>The progress handler will be called on the thread processing the request. This means that the implementation of the handler must take care not to block the thread or do anything that takes significant amounts of time. In particular, do not do any kind of I/O from within the handler, do not update user interfaces, and to not acquire any locks. If such activities are necessary, it is the handler's responsibility to execute that work on a separate thread. </p>

</div>
</div>
<a class="anchor" id="acea3e29c7c8665d35608fc4d51b9a3bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_request_uri </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1uri.html">uri</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the underling URI of the request message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>The uri for this message.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae38790c35476ea1214473d2fc6ed55c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_request::set_response_stream </td>
          <td>(</td>
          <td class="paramtype">const concurrency::streams::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to hold the body of the HTTP response message that results from the request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A writable, open asynchronous stream.</td></tr>
  </table>
  </dd>
</dl>
<p>If this function is called, the body of the response should not be accessed in any other way. </p>

</div>
</div>
<a class="anchor" id="a1e95dcdd5f609db1fd4d4ff2dfe4c5d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">utility::string_t web::http::http_request::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string representation of the message, including the body when possible. Mainly this should be used for debugging purposes as it has to copy the message body and doesn't have excellent performance. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representation of this HTTP request.</dd></dl>
<p>Note this function is synchronous and doesn't wait for the entire message body to arrive. If the message body has arrived by the time this function is called and it is has a textual Content-Type it will be included. Otherwise just the headers will be present.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cpprest/<a class="el" href="http__msg_8h_source.html">http_msg.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
