<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>C++ Rest SDK: Concurrency::streams::details::basic_streambuf&lt; _CharType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cloud.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Rest SDK
   </div>
   <div id="projectbrief">The C++ REST SDK is a Microsoft project for cloud-based client-server communication in native code using a modern asynchronous C++ API design. This project aims to help C++ developers connect to and interact with services.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Concurrency</b></li><li class="navelem"><a class="el" href="namespace_concurrency_1_1streams.html">streams</a></li><li class="navelem"><b>details</b></li><li class="navelem"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">basic_streambuf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Stream buffer base class.  
 <a href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="astreambuf_8h_source.html">astreambuf.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.png" usemap="#Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;_map" alt=""/>
  <map id="Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;_map" name="Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;_map">
<area href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html" alt="Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;" shape="rect" coords="709,56,1172,80"/>
<area href="class_concurrency_1_1streams_1_1streambuf.html" title="Reference-counted stream buffer. " alt="Concurrency::streams::streambuf&lt; _CharType &gt;" shape="rect" coords="2128,56,2591,80"/>
<area href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html" title="Private stream buffer implementation for file streams. The class itself should not be used in applica..." alt="Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;" shape="rect" coords="0,112,463,136"/>
<area href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html" title="The basic_producer_consumer_buffer class serves as a memory-based steam buffer that supports both wri..." alt="Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;" shape="rect" coords="473,112,936,136"/>
<area href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html" title="The basic_rawptr_buffer class serves as a memory-based steam buffer that supports both writing and re..." alt="Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;" shape="rect" coords="946,112,1409,136"/>
<area href="class_concurrency_1_1streams_1_1details_1_1basic__stdio__buffer.html" title="The basic_stdio_buffer class serves to support interoperability with STL stream buffers. Sitting atop a std::streambuf, which does all the I/O, instances of this class may read and write data to standard iostreams. The class itself should not be used in application code, it is used by the stream definitions farther down in the header file. " alt="Concurrency::streams::details::basic_stdio_buffer&lt; _CharType &gt;" shape="rect" coords="1419,112,1882,136"/>
<area href="class_concurrency_1_1streams_1_1producer__consumer__buffer.html" title="The producer_consumer_buffer class serves as a memory-based steam buffer that supports both writing a..." alt="Concurrency::streams::producer_consumer_buffer&lt; _CharType &gt;" shape="rect" coords="1892,112,2355,136"/>
<area href="class_concurrency_1_1streams_1_1rawptr__buffer.html" title="The rawptr_buffer class serves as a memory-based stream buffer that supports reading sequences of cha..." alt="Concurrency::streams::rawptr_buffer&lt; _CharType &gt;" shape="rect" coords="2365,112,2828,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7cd70561849f966823d4534aa38963ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cd70561849f966823d4534aa38963ad"></a>
typedef _CharType&#160;</td><td class="memItemRight" valign="bottom"><b>char_type</b></td></tr>
<tr class="separator:a7cd70561849f966823d4534aa38963ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc879afd2840d1df21fe86248910052"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dc879afd2840d1df21fe86248910052"></a>
typedef ::concurrency::streams::char_traits&lt; _CharType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>traits</b></td></tr>
<tr class="separator:a7dc879afd2840d1df21fe86248910052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ff619438b3e71e6f601bb518a67a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a079ff619438b3e71e6f601bb518a67a9"></a>
typedef traits::int_type&#160;</td><td class="memItemRight" valign="bottom"><b>int_type</b></td></tr>
<tr class="separator:a079ff619438b3e71e6f601bb518a67a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139102a6d042dc709717b97d2565fcf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a139102a6d042dc709717b97d2565fcf3"></a>
typedef traits::pos_type&#160;</td><td class="memItemRight" valign="bottom"><b>pos_type</b></td></tr>
<tr class="separator:a139102a6d042dc709717b97d2565fcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e021e969ca85d498840d5adee6f02e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e021e969ca85d498840d5adee6f02e3"></a>
typedef traits::off_type&#160;</td><td class="memItemRight" valign="bottom"><b>off_type</b></td></tr>
<tr class="separator:a9e021e969ca85d498840d5adee6f02e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae8d7242e86aa6bfba080a18afcdf610b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#ae8d7242e86aa6bfba080a18afcdf610b">~basic_streambuf</a> ()</td></tr>
<tr class="memdesc:ae8d7242e86aa6bfba080a18afcdf610b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor for stream buffers.  <a href="#ae8d7242e86aa6bfba080a18afcdf610b">More...</a><br /></td></tr>
<tr class="separator:ae8d7242e86aa6bfba080a18afcdf610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2335e901ca091ed71919c39f2eb93c0c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a2335e901ca091ed71919c39f2eb93c0c">can_read</a> () const  =0</td></tr>
<tr class="memdesc:a2335e901ca091ed71919c39f2eb93c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>can_read</code> is used to determine whether a stream buffer will support read operations (get).  <a href="#a2335e901ca091ed71919c39f2eb93c0c">More...</a><br /></td></tr>
<tr class="separator:a2335e901ca091ed71919c39f2eb93c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6074a528cce6fd4b48961768edfc40"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a8f6074a528cce6fd4b48961768edfc40">can_write</a> () const  =0</td></tr>
<tr class="memdesc:a8f6074a528cce6fd4b48961768edfc40"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>can_write</code> is used to determine whether a stream buffer will support write operations (put).  <a href="#a8f6074a528cce6fd4b48961768edfc40">More...</a><br /></td></tr>
<tr class="separator:a8f6074a528cce6fd4b48961768edfc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c15f6d53d985aefbaeea93d522baa4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a80c15f6d53d985aefbaeea93d522baa4">can_seek</a> () const  =0</td></tr>
<tr class="memdesc:a80c15f6d53d985aefbaeea93d522baa4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>can_seek<code> is used to determine whether a stream buffer supports seeking. </code></code><code><code> </code></code> <a href="#a80c15f6d53d985aefbaeea93d522baa4">More...</a><br /></td></tr>
<tr class="separator:a80c15f6d53d985aefbaeea93d522baa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91ebbdcb982d4d31531376a457502e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#aa91ebbdcb982d4d31531376a457502e7">has_size</a> () const  =0</td></tr>
<tr class="memdesc:aa91ebbdcb982d4d31531376a457502e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>has_size<code> is used to determine whether a stream buffer supports <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a5f18fddf494a4383d9689b131e080150" title="Gets the size of the stream, if known. Calls to has_size will determine whether the result of size ca...">size()</a>. </code></code><code><code> </code></code> <a href="#aa91ebbdcb982d4d31531376a457502e7">More...</a><br /></td></tr>
<tr class="separator:aa91ebbdcb982d4d31531376a457502e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c739ab9e5ce215f5ba5654d8cdf8fd0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a1c739ab9e5ce215f5ba5654d8cdf8fd0">is_eof</a> () const  =0</td></tr>
<tr class="memdesc:a1c739ab9e5ce215f5ba5654d8cdf8fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_eof</code> is used to determine whether a read head has reached the end of the buffer.  <a href="#a1c739ab9e5ce215f5ba5654d8cdf8fd0">More...</a><br /></td></tr>
<tr class="separator:a1c739ab9e5ce215f5ba5654d8cdf8fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950f82dd04da3cd7b3868e778a7abde0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a950f82dd04da3cd7b3868e778a7abde0">buffer_size</a> (std::ios_base::openmode direction=std::ios_base::in) const  =0</td></tr>
<tr class="memdesc:a950f82dd04da3cd7b3868e778a7abde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stream buffer size, if one has been set.  <a href="#a950f82dd04da3cd7b3868e778a7abde0">More...</a><br /></td></tr>
<tr class="separator:a950f82dd04da3cd7b3868e778a7abde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab85462baa0f80e502dced2587dd7db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a8ab85462baa0f80e502dced2587dd7db">set_buffer_size</a> (size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a5f18fddf494a4383d9689b131e080150">size</a>, std::ios_base::openmode direction=std::ios_base::in)=0</td></tr>
<tr class="memdesc:a8ab85462baa0f80e502dced2587dd7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stream buffer implementation to buffer or not buffer.  <a href="#a8ab85462baa0f80e502dced2587dd7db">More...</a><br /></td></tr>
<tr class="separator:a8ab85462baa0f80e502dced2587dd7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d87adbb1c2e175cd958ecbcbef6a36"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a78d87adbb1c2e175cd958ecbcbef6a36">in_avail</a> () const  =0</td></tr>
<tr class="memdesc:a78d87adbb1c2e175cd958ecbcbef6a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any input stream, <code>in_avail</code> returns the number of characters that are immediately available to be consumed without blocking. May be used in conjunction with &lt;cref="::sbumpc method"/&gt; to read data without incurring the overhead of using tasks.  <a href="#a78d87adbb1c2e175cd958ecbcbef6a36">More...</a><br /></td></tr>
<tr class="separator:a78d87adbb1c2e175cd958ecbcbef6a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16662ddfcca99b852b9421d1ea58507"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#ab16662ddfcca99b852b9421d1ea58507">is_open</a> () const  =0</td></tr>
<tr class="memdesc:ab16662ddfcca99b852b9421d1ea58507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream buffer is open.  <a href="#ab16662ddfcca99b852b9421d1ea58507">More...</a><br /></td></tr>
<tr class="separator:ab16662ddfcca99b852b9421d1ea58507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c03d843d8047e666e9dcdc6cc0256f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#ad4c03d843d8047e666e9dcdc6cc0256f">close</a> (std::ios_base::openmode mode=(std::ios_base::in|std::ios_base::out))=0</td></tr>
<tr class="memdesc:ad4c03d843d8047e666e9dcdc6cc0256f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream buffer, preventing further read or write operations.  <a href="#ad4c03d843d8047e666e9dcdc6cc0256f">More...</a><br /></td></tr>
<tr class="separator:ad4c03d843d8047e666e9dcdc6cc0256f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769af62e3efde5914a3c08ee78a6cc13"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a769af62e3efde5914a3c08ee78a6cc13">close</a> (std::ios_base::openmode mode, std::exception_ptr eptr)=0</td></tr>
<tr class="memdesc:a769af62e3efde5914a3c08ee78a6cc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream buffer with an exception.  <a href="#a769af62e3efde5914a3c08ee78a6cc13">More...</a><br /></td></tr>
<tr class="separator:a769af62e3efde5914a3c08ee78a6cc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd5216351c5ed91d6661968719c1efc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a6dd5216351c5ed91d6661968719c1efc">putc</a> (_CharType ch)=0</td></tr>
<tr class="memdesc:a6dd5216351c5ed91d6661968719c1efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single character to the stream.  <a href="#a6dd5216351c5ed91d6661968719c1efc">More...</a><br /></td></tr>
<tr class="separator:a6dd5216351c5ed91d6661968719c1efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3065f53c165a6b100d5ff4ce00d477e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a3065f53c165a6b100d5ff4ce00d477e4">putn</a> (const _CharType *ptr, size_t count)=0</td></tr>
<tr class="memdesc:a3065f53c165a6b100d5ff4ce00d477e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a number of characters to the stream.  <a href="#a3065f53c165a6b100d5ff4ce00d477e4">More...</a><br /></td></tr>
<tr class="separator:a3065f53c165a6b100d5ff4ce00d477e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558048d944a5fa3d59e2723a1733abbb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a558048d944a5fa3d59e2723a1733abbb">putn_nocopy</a> (const _CharType *ptr, size_t count)=0</td></tr>
<tr class="memdesc:a558048d944a5fa3d59e2723a1733abbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a number of characters to the stream. Note: callers must make sure the data to be written is valid until the returned task completes.  <a href="#a558048d944a5fa3d59e2723a1733abbb">More...</a><br /></td></tr>
<tr class="separator:a558048d944a5fa3d59e2723a1733abbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747d5a580f8723719d22b37a1a5ddb74"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a747d5a580f8723719d22b37a1a5ddb74">bumpc</a> ()=0</td></tr>
<tr class="memdesc:a747d5a580f8723719d22b37a1a5ddb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream and advances the read position.  <a href="#a747d5a580f8723719d22b37a1a5ddb74">More...</a><br /></td></tr>
<tr class="separator:a747d5a580f8723719d22b37a1a5ddb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc56f6145651a40ec62fafff1d7fcf0"><td class="memItemLeft" align="right" valign="top">virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a6bc56f6145651a40ec62fafff1d7fcf0">sbumpc</a> ()=0</td></tr>
<tr class="memdesc:a6bc56f6145651a40ec62fafff1d7fcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream and advances the read position.  <a href="#a6bc56f6145651a40ec62fafff1d7fcf0">More...</a><br /></td></tr>
<tr class="separator:a6bc56f6145651a40ec62fafff1d7fcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de94cdebb61c424e083d04f8305b338"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a2de94cdebb61c424e083d04f8305b338">getc</a> ()=0</td></tr>
<tr class="memdesc:a2de94cdebb61c424e083d04f8305b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream without advancing the read position.  <a href="#a2de94cdebb61c424e083d04f8305b338">More...</a><br /></td></tr>
<tr class="separator:a2de94cdebb61c424e083d04f8305b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8ebacdf59755dddc8330fbf4b8967c"><td class="memItemLeft" align="right" valign="top">virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#abb8ebacdf59755dddc8330fbf4b8967c">sgetc</a> ()=0</td></tr>
<tr class="memdesc:abb8ebacdf59755dddc8330fbf4b8967c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream without advancing the read position.  <a href="#abb8ebacdf59755dddc8330fbf4b8967c">More...</a><br /></td></tr>
<tr class="separator:abb8ebacdf59755dddc8330fbf4b8967c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b6dc19c43e33bb9687dca6d6414e55"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a59b6dc19c43e33bb9687dca6d6414e55">nextc</a> ()=0</td></tr>
<tr class="memdesc:a59b6dc19c43e33bb9687dca6d6414e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the read position, then returns the next character without advancing again.  <a href="#a59b6dc19c43e33bb9687dca6d6414e55">More...</a><br /></td></tr>
<tr class="separator:a59b6dc19c43e33bb9687dca6d6414e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9680265ce8eb48e167d502b45181a285"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a9680265ce8eb48e167d502b45181a285">ungetc</a> ()=0</td></tr>
<tr class="memdesc:a9680265ce8eb48e167d502b45181a285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retreats the read position, then returns the current character without advancing.  <a href="#a9680265ce8eb48e167d502b45181a285">More...</a><br /></td></tr>
<tr class="separator:a9680265ce8eb48e167d502b45181a285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bd5671e84946c5597a7090860693f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a34bd5671e84946c5597a7090860693f0">getn</a> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)=0</td></tr>
<tr class="memdesc:a34bd5671e84946c5597a7090860693f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads up to a given number of characters from the stream.  <a href="#a34bd5671e84946c5597a7090860693f0">More...</a><br /></td></tr>
<tr class="separator:a34bd5671e84946c5597a7090860693f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcc77b99e3dc8ee3819472f1611f650"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#aadcc77b99e3dc8ee3819472f1611f650">scopy</a> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)=0</td></tr>
<tr class="memdesc:aadcc77b99e3dc8ee3819472f1611f650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to a given number of characters from the stream, synchronously.  <a href="#aadcc77b99e3dc8ee3819472f1611f650">More...</a><br /></td></tr>
<tr class="separator:aadcc77b99e3dc8ee3819472f1611f650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab8d95cff200323ab2cb803539e455b"><td class="memItemLeft" align="right" valign="top">virtual pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#afab8d95cff200323ab2cb803539e455b">getpos</a> (std::ios_base::openmode direction) const  =0</td></tr>
<tr class="memdesc:afab8d95cff200323ab2cb803539e455b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current read or write position in the stream.  <a href="#afab8d95cff200323ab2cb803539e455b">More...</a><br /></td></tr>
<tr class="separator:afab8d95cff200323ab2cb803539e455b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f18fddf494a4383d9689b131e080150"><td class="memItemLeft" align="right" valign="top">virtual utility::size64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a5f18fddf494a4383d9689b131e080150">size</a> () const  =0</td></tr>
<tr class="memdesc:a5f18fddf494a4383d9689b131e080150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the stream, if known. Calls to <code>has_size</code> will determine whether the result of <code>size</code> can be relied on.  <a href="#a5f18fddf494a4383d9689b131e080150">More...</a><br /></td></tr>
<tr class="separator:a5f18fddf494a4383d9689b131e080150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191bbcc02a82bf9adb80147b1e608baa"><td class="memItemLeft" align="right" valign="top">virtual pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a191bbcc02a82bf9adb80147b1e608baa">seekpos</a> (pos_type pos, std::ios_base::openmode direction)=0</td></tr>
<tr class="memdesc:a191bbcc02a82bf9adb80147b1e608baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeks to the given position.  <a href="#a191bbcc02a82bf9adb80147b1e608baa">More...</a><br /></td></tr>
<tr class="separator:a191bbcc02a82bf9adb80147b1e608baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f681addd941123a660ef0c2acd4ed8"><td class="memItemLeft" align="right" valign="top">virtual pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#ac4f681addd941123a660ef0c2acd4ed8">seekoff</a> (off_type offset, std::ios_base::seekdir way, std::ios_base::openmode mode)=0</td></tr>
<tr class="memdesc:ac4f681addd941123a660ef0c2acd4ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeks to a position given by a relative offset.  <a href="#ac4f681addd941123a660ef0c2acd4ed8">More...</a><br /></td></tr>
<tr class="separator:ac4f681addd941123a660ef0c2acd4ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ad984f0acf241a825d4feaf24f027a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a14ad984f0acf241a825d4feaf24f027a">sync</a> ()=0</td></tr>
<tr class="memdesc:a14ad984f0acf241a825d4feaf24f027a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For output streams, flush any internally buffered data to the underlying medium.  <a href="#a14ad984f0acf241a825d4feaf24f027a">More...</a><br /></td></tr>
<tr class="separator:a14ad984f0acf241a825d4feaf24f027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcdb3c58237bcae05dd7a5649fb25e9"><td class="memItemLeft" align="right" valign="top">virtual _CharType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a5fcdb3c58237bcae05dd7a5649fb25e9">alloc</a> (_In_ size_t count)=0</td></tr>
<tr class="memdesc:a5fcdb3c58237bcae05dd7a5649fb25e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a contiguous memory block and returns it.  <a href="#a5fcdb3c58237bcae05dd7a5649fb25e9">More...</a><br /></td></tr>
<tr class="separator:a5fcdb3c58237bcae05dd7a5649fb25e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019704086210ed4d54f009cb9105a118"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a019704086210ed4d54f009cb9105a118">commit</a> (_In_ size_t count)=0</td></tr>
<tr class="memdesc:a019704086210ed4d54f009cb9105a118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a block already allocated by the stream buffer.  <a href="#a019704086210ed4d54f009cb9105a118">More...</a><br /></td></tr>
<tr class="separator:a019704086210ed4d54f009cb9105a118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc68282f1bfa06b97e09380e3b64405"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#aafc68282f1bfa06b97e09380e3b64405">acquire</a> (_Out_ _CharType *&amp;ptr, _Out_ size_t &amp;count)=0</td></tr>
<tr class="memdesc:aafc68282f1bfa06b97e09380e3b64405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the next already allocated contiguous block of data.  <a href="#aafc68282f1bfa06b97e09380e3b64405">More...</a><br /></td></tr>
<tr class="separator:aafc68282f1bfa06b97e09380e3b64405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829c3e1b9a75cdfcc50eef9757bf9726"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a829c3e1b9a75cdfcc50eef9757bf9726">release</a> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)=0</td></tr>
<tr class="memdesc:a829c3e1b9a75cdfcc50eef9757bf9726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a block of data acquired using ::acquire method. This frees the stream buffer to de-allocate the memory, if it so desires. Move the read position ahead by the count.  <a href="#a829c3e1b9a75cdfcc50eef9757bf9726">More...</a><br /></td></tr>
<tr class="separator:a829c3e1b9a75cdfcc50eef9757bf9726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1c7371c3f4de604c7aece1ee868f11"><td class="memItemLeft" align="right" valign="top">virtual std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#aea1c7371c3f4de604c7aece1ee868f11">exception</a> () const  =0</td></tr>
<tr class="memdesc:aea1c7371c3f4de604c7aece1ee868f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stream buffer exception_ptr if it has been set.  <a href="#aea1c7371c3f4de604c7aece1ee868f11">More...</a><br /></td></tr>
<tr class="separator:aea1c7371c3f4de604c7aece1ee868f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _CharType&gt;<br />
class Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</h3>

<p>Stream buffer base class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae8d7242e86aa6bfba080a18afcdf610b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::~<a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">basic_streambuf</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual constructor for stream buffers. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aafc68282f1bfa06b97e09380e3b64405"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::acquire </td>
          <td>(</td>
          <td class="paramtype">_Out_ _CharType *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Out_ size_t &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to the next already allocated contiguous block of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A reference to a pointer variable that will hold the address of the block on success.</td></tr>
    <tr><td class="paramname">count</td><td>The number of contiguous characters available at the address in 'ptr.'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation succeeded, <code>false</code> otherwise.</dd></dl>
<p>A return of false does not necessarily indicate that a subsequent read operation would fail, only that there is no block to return immediately or that the stream buffer does not support the operation. The stream buffer may not de-allocate the block until ::release method is called. If the end of the stream is reached, the function will return <code>true</code>, a null pointer, and a count of zero; a subsequent read will not succeed. </p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ad19730d8637ba56baf9283041ea68bc3">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ad19730d8637ba56baf9283041ea68bc3">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#af1181d462ac3478fb33352d9f1226cba">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#a90b8549d49093cab2dbdfd7c506c990d">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a709dfe7834df8d5d9e829f5a0e37f138">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#aebb5c5fae35d57415d42d412c9e84ce0">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5fcdb3c58237bcae05dd7a5649fb25e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual _CharType* <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::alloc </td>
          <td>(</td>
          <td class="paramtype">_In_ size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a contiguous memory block and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of characters to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a block to write to, null if the stream buffer implementation does not support alloc/commit.</dd></dl>

</div>
</div>
<a class="anchor" id="a950f82dd04da3cd7b3868e778a7abde0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::buffer_size </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>direction</em> = <code>std::ios_base::in</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the stream buffer size, if one has been set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The direction of buffering (in or out)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the internal buffer (for the given direction).</dd></dl>
<p>An implementation that does not support buffering will always return 0.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a646e484a87f1bf76fee3c4967054c8d4">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a646e484a87f1bf76fee3c4967054c8d4">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a909ec3a6fc564cb06937aff9cea896b0">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a909ec3a6fc564cb06937aff9cea896b0">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a165cae38f8a333a875abb0f56831a52b">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#a7ebda374de3b831b89b934cfddd999c4">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#acaa1f184f84d1084c18328e69c4c8791">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a4afbd85aa213c07ce0968c62a651c0de">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a747d5a580f8723719d22b37a1a5ddb74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::bumpc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single character from the stream and advances the read position. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that holds the value of the character. This value is EOF if the read fails.</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#aa2403d48395ee880846281f81425d92a">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#aa2403d48395ee880846281f81425d92a">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2e9f0ad2b5ddf49b316751aa18a9cf58">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2e9f0ad2b5ddf49b316751aa18a9cf58">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2335e901ca091ed71919c39f2eb93c0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::can_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>can_read</code> is used to determine whether a stream buffer will support read operations (get). </p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ae19dc96f6e0de2d35cbceae2b6dbbcfc">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ae19dc96f6e0de2d35cbceae2b6dbbcfc">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aed2334bda427e1aab975a6ddc9179187">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aed2334bda427e1aab975a6ddc9179187">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a80c15f6d53d985aefbaeea93d522baa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::can_seek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>can_seek<code> is used to determine whether a stream buffer supports seeking. </code></code><code><code> </code></code></p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a834efc1922550262f94426413f12e825">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a834efc1922550262f94426413f12e825">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a76fc42530539a84f98b1d1f48cb2fcd0">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a76fc42530539a84f98b1d1f48cb2fcd0">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a103c624ba65828b372599664a6428380">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a8e858e01ca9cc523cf5e93c541fa08f1">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#a3dfa0ffcfb66c7f6ab9fe8ea363bd441">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#af343d4627e24beac6726778d9d69622d">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8f6074a528cce6fd4b48961768edfc40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::can_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>can_write</code> is used to determine whether a stream buffer will support write operations (put). </p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#adcb7c22636af9e5b78cfaf636ee77b9f">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#adcb7c22636af9e5b78cfaf636ee77b9f">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a548ca961ef6062e52094679745b5a3c2">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a548ca961ef6062e52094679745b5a3c2">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad4c03d843d8047e666e9dcdc6cc0256f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::close </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>(std::ios_base::in|std::ios_base::out)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the stream buffer, preventing further read or write operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The I/O mode (in or out) to close for.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#acb4c16359ecfd011266852e474e765a6">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#acb4c16359ecfd011266852e474e765a6">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#af7e2852cda70d6424ef8787ebbd3c25f">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#af7e2852cda70d6424ef8787ebbd3c25f">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#aeb6fccf66e7b5375bcb53ac6f0f56b38">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a769af62e3efde5914a3c08ee78a6cc13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::close </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::exception_ptr&#160;</td>
          <td class="paramname"><em>eptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the stream buffer with an exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The I/O mode (in or out) to close for.</td></tr>
    <tr><td class="paramname">eptr</td><td>Pointer to the exception.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a074abc74a37078743993ac1f43e95d4f">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a074abc74a37078743993ac1f43e95d4f">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a749a8c69f0c9870ab534ebe2b1e0914c">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a749a8c69f0c9870ab534ebe2b1e0914c">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a019704086210ed4d54f009cb9105a118"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::commit </td>
          <td>(</td>
          <td class="paramtype">_In_ size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a block already allocated by the stream buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of characters to be committed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea1c7371c3f4de604c7aece1ee868f11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::exception_ptr <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::exception </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the stream buffer exception_ptr if it has been set. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the exception, if it has been set; otherwise, <code>nullptr</code> will be returned</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#abde6c984187f610c2cc2791e511ac280">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#abde6c984187f610c2cc2791e511ac280">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2fd1d77a11059cc5f7f379b54bf56e53">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2fd1d77a11059cc5f7f379b54bf56e53">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2de94cdebb61c424e083d04f8305b338"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::getc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single character from the stream without advancing the read position. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that holds the value of the byte. This value is EOF if the read fails.</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a904f398939c6ab8d714a43a76de1add2">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a904f398939c6ab8d714a43a76de1add2">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa6c5d6cdc4f5dfcdd2859b4fa3872c95">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa6c5d6cdc4f5dfcdd2859b4fa3872c95">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a34bd5671e84946c5597a7090860693f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;size_t&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::getn </td>
          <td>(</td>
          <td class="paramtype">_Out_writes_(count) _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_In_ size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads up to a given number of characters from the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The address of the target memory area.</td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of characters to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that holds the number of characters read. This value is O if the end of the stream is reached.</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#aabe0686b37a78411685bbb13c8537396">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#aabe0686b37a78411685bbb13c8537396">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2e03bfa260c8b9a2678e86c1c980c3a5">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2e03bfa260c8b9a2678e86c1c980c3a5">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afab8d95cff200323ab2cb803539e455b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::getpos </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current read or write position in the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The I/O direction to seek (see remarks)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current position. EOF if the operation fails.</dd></dl>
<p>Some streams may have separate write and read cursors. For such streams, the direction parameter defines whether to move the read or the write cursor.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ab04e74e50654e26d26ce4abef612411c">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ab04e74e50654e26d26ce4abef612411c">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a4acd807ca4d033cef91de1acd4f41fc3">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a4acd807ca4d033cef91de1acd4f41fc3">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a3bb78aa602b1b5891be539e2afca4729">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#a658c28580b4cb1e7d7751ca1844ddf52">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a5930518c77994f3000dc0cd3ac1e39c7">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a7be25566723239022f11be55ec4396b8">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa91ebbdcb982d4d31531376a457502e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::has_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>has_size<code> is used to determine whether a stream buffer supports <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a5f18fddf494a4383d9689b131e080150" title="Gets the size of the stream, if known. Calls to has_size will determine whether the result of size ca...">size()</a>. </code></code><code><code> </code></code></p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a4e2cdbf3d137815f93afb0192e8b285d">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a4e2cdbf3d137815f93afb0192e8b285d">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a1e719975f42244d923c72e2e322faa07">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a1e719975f42244d923c72e2e322faa07">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a11d3fd79869d4dbae639d09c270d30de">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a0e78e8e09631df4b23e17c66f275a101">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#aea293fd2f77d23b35fd769bb13387301">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a95e0854abbf6e1002372e5ffff3c4b97">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a78d87adbb1c2e175cd958ecbcbef6a36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::in_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For any input stream, <code>in_avail</code> returns the number of characters that are immediately available to be consumed without blocking. May be used in conjunction with &lt;cref="::sbumpc method"/&gt; to read data without incurring the overhead of using tasks. </p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a849c49b08d2c1e81ec0b1762e56b9082">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a849c49b08d2c1e81ec0b1762e56b9082">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a1e02ea1d54f3b1203787616bf8340430">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a1e02ea1d54f3b1203787616bf8340430">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a87aec0d5fb4748b6a676d065023b14e3">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#ac388d4163132ff835b1ddfdefb12b9f9">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#ac38043172f7d0b9a36b45f52c1c57205">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#af7dc60cde0798585d46a842adedc122b">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1c739ab9e5ce215f5ba5654d8cdf8fd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::is_eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_eof</code> is used to determine whether a read head has reached the end of the buffer. </p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#afc28bdccd0e099de55919e3f9deef203">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#afc28bdccd0e099de55919e3f9deef203">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a70ec23de40fe0390b6eeed04ac352de1">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a70ec23de40fe0390b6eeed04ac352de1">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab16662ddfcca99b852b9421d1ea58507"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream buffer is open. </p>
<p>No separation is made between open for reading and open for writing.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#adfcb0faa00c0f30a9bb2d946cab1a4db">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#adfcb0faa00c0f30a9bb2d946cab1a4db">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ae803b65c032ea6e9dcd54b92e0c9d512">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ae803b65c032ea6e9dcd54b92e0c9d512">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a59b6dc19c43e33bb9687dca6d6414e55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::nextc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the read position, then returns the next character without advancing again. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that holds the value of the character. This value is EOF if the read fails.</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a5ba3cf48943dfdd814e0eb611ea8cfd0">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a5ba3cf48943dfdd814e0eb611ea8cfd0">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#acee850cc04e3ca57084ab11523e1db2e">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#acee850cc04e3ca57084ab11523e1db2e">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6dd5216351c5ed91d6661968719c1efc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::putc </td>
          <td>(</td>
          <td class="paramtype">_CharType&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a single character to the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that holds the value of the character. This value is EOF if the write operation fails.</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a537c97175eed91c0ecff4dcc3bfc49da">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a537c97175eed91c0ecff4dcc3bfc49da">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a380b990b895a20224ca45d6c7c11190c">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a380b990b895a20224ca45d6c7c11190c">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3065f53c165a6b100d5ff4ce00d477e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;size_t&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::putn </td>
          <td>(</td>
          <td class="paramtype">const _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a number of characters to the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the block of data to be written.</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that holds the number of characters actually written, either 'count' or 0.</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a01d96caf0991697b7b7a240f392527cf">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a01d96caf0991697b7b7a240f392527cf">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a4927b4f17f050f1fd10ed599cb49b836">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a4927b4f17f050f1fd10ed599cb49b836">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a558048d944a5fa3d59e2723a1733abbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;size_t&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::putn_nocopy </td>
          <td>(</td>
          <td class="paramtype">const _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a number of characters to the stream. Note: callers must make sure the data to be written is valid until the returned task completes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the block of data to be written.</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that holds the number of characters actually written, either 'count' or 0.</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ad58aae28ed72d8ac734fcc7b940894ec">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ad58aae28ed72d8ac734fcc7b940894ec">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a48557a7d9d216500f879abc912b5f24f">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a48557a7d9d216500f879abc912b5f24f">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a829c3e1b9a75cdfcc50eef9757bf9726"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::release </td>
          <td>(</td>
          <td class="paramtype">_Out_writes_(count) _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_In_ size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a block of data acquired using ::acquire method. This frees the stream buffer to de-allocate the memory, if it so desires. Move the read position ahead by the count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the block of data to be released.</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters that were read.</td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a4e1645fcdf1b616a795c55de338ec26b">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a4e1645fcdf1b616a795c55de338ec26b">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a68390e9e8286f7911bde2dd91bbbf209">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a68390e9e8286f7911bde2dd91bbbf209">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a0466072dc98c90be1326f1a0269af131">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6bc56f6145651a40ec62fafff1d7fcf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::sbumpc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single character from the stream and advances the read position. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the character. <code>-1</code> if the read fails. <code>-2</code> if an asynchronous read is required</dd></dl>
<p>This is a synchronous operation, but is guaranteed to never block.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a4d1bb1af2bf59da089ffb2488f3ad643">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a4d1bb1af2bf59da089ffb2488f3ad643">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa3f5fd8cab84a41d75e8476015e83331">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa3f5fd8cab84a41d75e8476015e83331">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aadcc77b99e3dc8ee3819472f1611f650"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::scopy </td>
          <td>(</td>
          <td class="paramtype">_Out_writes_(count) _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_In_ size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies up to a given number of characters from the stream, synchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The address of the target memory area.</td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of characters to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters copied. O if the end of the stream is reached or an asynchronous read is required.</dd></dl>
<p>This is a synchronous operation, but is guaranteed to never block.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a17f3116397a14f7b537fa4f0d001116f">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a17f3116397a14f7b537fa4f0d001116f">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ac759d4d90e6b33da98ed8f495c138dd8">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ac759d4d90e6b33da98ed8f495c138dd8">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac4f681addd941123a660ef0c2acd4ed8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::seekoff </td>
          <td>(</td>
          <td class="paramtype">off_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::seekdir&#160;</td>
          <td class="paramname"><em>way</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seeks to a position given by a relative offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The relative position to seek to</td></tr>
    <tr><td class="paramname">way</td><td>The starting point (beginning, end, current) for the seek.</td></tr>
    <tr><td class="paramname">mode</td><td>The I/O direction to seek (see remarks)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position. EOF if the operation fails.</dd></dl>
<p>Some streams may have separate write and read cursors. For such streams, the mode parameter defines whether to move the read or the write cursor.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2d7a83da4fc15bda3e02dbc91d21bc2a">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2d7a83da4fc15bda3e02dbc91d21bc2a">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a9808080aea0eb05b86159faefbcc4ded">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#a1ea35b3503c4c5019725bbeea8ea95e1">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a84838b4b0c8744033a66502af46c08e1">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#ab02ca807438f07bd855042c2c3f9fca9">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a191bbcc02a82bf9adb80147b1e608baa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::seekpos </td>
          <td>(</td>
          <td class="paramtype">pos_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seeks to the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The offset from the beginning of the stream.</td></tr>
    <tr><td class="paramname">direction</td><td>The I/O direction to seek (see remarks).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position. EOF if the operation fails.</dd></dl>
<p>Some streams may have separate write and read cursors. For such streams, the direction parameter defines whether to move the read or the write cursor.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a771c9acc022390635bad4453f59a44dc">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a771c9acc022390635bad4453f59a44dc">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a7fa36f1ebd1c1b3df9ac013cf4ca6281">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#ac19138ac861d195e0b079f53588aeaea">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#aa04c4bd7ed732a85db022f94337dd265">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#ade9aa941bea86f52a8fa18cb5d14d5a6">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8ab85462baa0f80e502dced2587dd7db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::set_buffer_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>direction</em> = <code>std::ios_base::in</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the stream buffer implementation to buffer or not buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to use for internal buffering, 0 if no buffering should be done.</td></tr>
    <tr><td class="paramname">direction</td><td>The direction of buffering (in or out)</td></tr>
  </table>
  </dd>
</dl>
<p>An implementation that does not support buffering will silently ignore calls to this function and it will not have any effect on what is returned by subsequent calls to ::buffer_size method.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ae415c5d42aa2b0f883fcbb74bd8ecd59">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#ae415c5d42aa2b0f883fcbb74bd8ecd59">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a302f500fe45a006d6e264d320f87b3e9">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a302f500fe45a006d6e264d320f87b3e9">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a8532562328084423ebf184d56103f63e">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#ad11103373e2f56d353276d0c843febfd">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#ad0d303f2025cb5160ed7d06d0b26a768">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a592befff2e1cd62552fc4a026a2c50c6">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abb8ebacdf59755dddc8330fbf4b8967c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::sgetc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single character from the stream without advancing the read position. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the character. EOF if the read fails. ::requires_async method if an asynchronous read is required</dd></dl>
<p>This is a synchronous operation, but is guaranteed to never block.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a14d89ecf70372e17d0725e65fc8f01c9">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a14d89ecf70372e17d0725e65fc8f01c9">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ac9df9f0e827354a4f3d673e6d2643f52">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ac9df9f0e827354a4f3d673e6d2643f52">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5f18fddf494a4383d9689b131e080150"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual utility::size64_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the stream, if known. Calls to <code>has_size</code> will determine whether the result of <code>size</code> can be relied on. </p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#afa53eeb7f3c5c70345b09e2dec87a8e2">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#afa53eeb7f3c5c70345b09e2dec87a8e2">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a6d2e4ca19b7eda6cd5348768d9c3f548">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a6d2e4ca19b7eda6cd5348768d9c3f548">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a7e086cd919b71a4df34e829433871501">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#aafb04c0576d1a02514a3ddcd72e03565">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a7ba5b293e0e73d0e09ddc67fb398899c">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a14ad984f0acf241a825d4feaf24f027a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For output streams, flush any internally buffered data to the underlying medium. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that returns <code>true</code> if the sync succeeds, <code>false</code> if not.</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a3c9e1f00b818b0c914ef2cbe6739fd88">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a3c9e1f00b818b0c914ef2cbe6739fd88">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a747f7e31451884a9448be43d11680285">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a747f7e31451884a9448be43d11680285">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9680265ce8eb48e167d502b45181a285"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf</a>&lt; _CharType &gt;::ungetc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retreats the read position, then returns the current character without advancing. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that holds the value of the character. This value is EOF if the read fails, <code>requires_async</code> if an asynchronous read is required</dd></dl>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a8ceb84822e618d2440f2a8064c8d0a7b">Concurrency::streams::streambuf&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1streambuf.html#a8ceb84822e618d2440f2a8064c8d0a7b">Concurrency::streams::streambuf&lt; _CollectionType::value_type &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a5c2c264214da39baadca7755be4a9e0e">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a5c2c264214da39baadca7755be4a9e0e">Concurrency::streams::details::streambuf_state_manager&lt; _CollectionType::value_type &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cpprest/<a class="el" href="astreambuf_8h_source.html">astreambuf.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
