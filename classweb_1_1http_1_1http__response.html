<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>C++ Rest SDK: web::http::http_response Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cloud.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Rest SDK
   </div>
   <div id="projectbrief">The C++ REST SDK is a Microsoft project for cloud-based client-server communication in native code using a modern asynchronous C++ API design. This project aims to help C++ developers connect to and interact with services.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceweb.html">web</a></li><li class="navelem"><a class="el" href="namespaceweb_1_1http.html">http</a></li><li class="navelem"><a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classweb_1_1http_1_1http__response-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">web::http::http_response Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents an HTTP response.  
 <a href="classweb_1_1http_1_1http__response.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="http__msg_8h_source.html">http_msg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2ee403657d29cc52abb94a7a9b0571c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#ae2ee403657d29cc52abb94a7a9b0571c">http_response</a> ()</td></tr>
<tr class="memdesc:ae2ee403657d29cc52abb94a7a9b0571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a response with an empty status code, no headers, and no body.  <a href="#ae2ee403657d29cc52abb94a7a9b0571c">More...</a><br /></td></tr>
<tr class="separator:ae2ee403657d29cc52abb94a7a9b0571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d11a840d30737505c614c82a716c06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a91d11a840d30737505c614c82a716c06">http_response</a> (http::status_code code)</td></tr>
<tr class="memdesc:a91d11a840d30737505c614c82a716c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a response with given status code, no headers, and no body.  <a href="#a91d11a840d30737505c614c82a716c06">More...</a><br /></td></tr>
<tr class="separator:a91d11a840d30737505c614c82a716c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca073a1623724b450f56c5c3f9eb043"><td class="memItemLeft" align="right" valign="top">http::status_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a0ca073a1623724b450f56c5c3f9eb043">status_code</a> () const </td></tr>
<tr class="memdesc:a0ca073a1623724b450f56c5c3f9eb043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the status code of the response message.  <a href="#a0ca073a1623724b450f56c5c3f9eb043">More...</a><br /></td></tr>
<tr class="separator:a0ca073a1623724b450f56c5c3f9eb043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ecc55265b87f0749ba5ba7e3902233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a17ecc55265b87f0749ba5ba7e3902233">set_status_code</a> (http::status_code code) const </td></tr>
<tr class="memdesc:a17ecc55265b87f0749ba5ba7e3902233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the status code of the response message.  <a href="#a17ecc55265b87f0749ba5ba7e3902233">More...</a><br /></td></tr>
<tr class="separator:a17ecc55265b87f0749ba5ba7e3902233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926da1cf11129fd92c2c7919597fdead"><td class="memItemLeft" align="right" valign="top">const http::reason_phrase &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a926da1cf11129fd92c2c7919597fdead">reason_phrase</a> () const </td></tr>
<tr class="memdesc:a926da1cf11129fd92c2c7919597fdead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reason phrase of the response message. If no reason phrase is set it will default to the standard one corresponding to the status code.  <a href="#a926da1cf11129fd92c2c7919597fdead">More...</a><br /></td></tr>
<tr class="separator:a926da1cf11129fd92c2c7919597fdead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bd6a4c59a88eabbc4318ad2483acb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#ab0bd6a4c59a88eabbc4318ad2483acb2">set_reason_phrase</a> (const http::reason_phrase &amp;reason) const </td></tr>
<tr class="memdesc:ab0bd6a4c59a88eabbc4318ad2483acb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reason phrase of the response message. If no reason phrase is set it will default to the standard one corresponding to the status code.  <a href="#ab0bd6a4c59a88eabbc4318ad2483acb2">More...</a><br /></td></tr>
<tr class="separator:ab0bd6a4c59a88eabbc4318ad2483acb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88105e4a2ae4b71824346816ce8757af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a88105e4a2ae4b71824346816ce8757af">headers</a> ()</td></tr>
<tr class="memdesc:a88105e4a2ae4b71824346816ce8757af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the headers of the response message.  <a href="#a88105e4a2ae4b71824346816ce8757af">More...</a><br /></td></tr>
<tr class="separator:a88105e4a2ae4b71824346816ce8757af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b24391efb8111ceb4f1f9396911a49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#ae9b24391efb8111ceb4f1f9396911a49">headers</a> () const </td></tr>
<tr class="memdesc:ae9b24391efb8111ceb4f1f9396911a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a const reference to the headers of the response message.  <a href="#ae9b24391efb8111ceb4f1f9396911a49">More...</a><br /></td></tr>
<tr class="separator:ae9b24391efb8111ceb4f1f9396911a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2e87b8b4aacdec1aad9a8f7c0baae9"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#afe2e87b8b4aacdec1aad9a8f7c0baae9">to_string</a> () const </td></tr>
<tr class="memdesc:afe2e87b8b4aacdec1aad9a8f7c0baae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string representation of the message, including the body when possible. Mainly this should be used for debugging purposes as it has to copy the message body and doesn't have excellent performance.  <a href="#afe2e87b8b4aacdec1aad9a8f7c0baae9">More...</a><br /></td></tr>
<tr class="separator:afe2e87b8b4aacdec1aad9a8f7c0baae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1272e1a1e855c1433abd31a76ef3be97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a1272e1a1e855c1433abd31a76ef3be97">extract_string</a> (bool ignore_content_type=false) const </td></tr>
<tr class="memdesc:a1272e1a1e855c1433abd31a76ef3be97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the response message as a string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#a1272e1a1e855c1433abd31a76ef3be97">More...</a><br /></td></tr>
<tr class="separator:a1272e1a1e855c1433abd31a76ef3be97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d642c983c580aea8bcbe60dbe21bfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; utf8string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a05d642c983c580aea8bcbe60dbe21bfc">extract_utf8string</a> (bool ignore_content_type=false) const </td></tr>
<tr class="memdesc:a05d642c983c580aea8bcbe60dbe21bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the response message as a UTF-8 string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#a05d642c983c580aea8bcbe60dbe21bfc">More...</a><br /></td></tr>
<tr class="separator:a05d642c983c580aea8bcbe60dbe21bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d4b658f735dfd922eb281e0e0b9217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; utf16string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a99d4b658f735dfd922eb281e0e0b9217">extract_utf16string</a> (bool ignore_content_type=false) const </td></tr>
<tr class="memdesc:a99d4b658f735dfd922eb281e0e0b9217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the response message as a UTF-16 string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#a99d4b658f735dfd922eb281e0e0b9217">More...</a><br /></td></tr>
<tr class="separator:a99d4b658f735dfd922eb281e0e0b9217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de616fedbe4b50ce5a67bce00675968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a2de616fedbe4b50ce5a67bce00675968">extract_json</a> (bool ignore_content_type=false) const </td></tr>
<tr class="memdesc:a2de616fedbe4b50ce5a67bce00675968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the response message into a json value, checking that the content type is application/json. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#a2de616fedbe4b50ce5a67bce00675968">More...</a><br /></td></tr>
<tr class="separator:a2de616fedbe4b50ce5a67bce00675968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc26d0a1f79f0f31fdd6ec78a939cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; std::vector&lt; unsigned char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a2dc26d0a1f79f0f31fdd6ec78a939cf0">extract_vector</a> () const </td></tr>
<tr class="memdesc:a2dc26d0a1f79f0f31fdd6ec78a939cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the response message into a vector of bytes.  <a href="#a2dc26d0a1f79f0f31fdd6ec78a939cf0">More...</a><br /></td></tr>
<tr class="separator:a2dc26d0a1f79f0f31fdd6ec78a939cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb92b43a0d79024ebd658830baae155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#aceb92b43a0d79024ebd658830baae155">set_body</a> (utf8string &amp;&amp;body_text, const utf8string &amp;content_type=utf8string(&quot;text/plain; charset=utf-8&quot;))</td></tr>
<tr class="memdesc:aceb92b43a0d79024ebd658830baae155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-8.  <a href="#aceb92b43a0d79024ebd658830baae155">More...</a><br /></td></tr>
<tr class="separator:aceb92b43a0d79024ebd658830baae155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092bfc840766247d5f3a4971a0164418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a092bfc840766247d5f3a4971a0164418">set_body</a> (const utf8string &amp;body_text, const utf8string &amp;content_type=utf8string(&quot;text/plain; charset=utf-8&quot;))</td></tr>
<tr class="memdesc:a092bfc840766247d5f3a4971a0164418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-8.  <a href="#a092bfc840766247d5f3a4971a0164418">More...</a><br /></td></tr>
<tr class="separator:a092bfc840766247d5f3a4971a0164418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3735268323742c7e078c8c30ebdea611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a3735268323742c7e078c8c30ebdea611">set_body</a> (const utf16string &amp;body_text, utf16string content_type=::<a class="el" href="namespaceutility_1_1conversions.html#ac56351f05efb283401aac4249b816894">utility::conversions::to_utf16string</a>(&quot;text/plain&quot;))</td></tr>
<tr class="memdesc:a3735268323742c7e078c8c30ebdea611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-16 will perform conversion to UTF-8.  <a href="#a3735268323742c7e078c8c30ebdea611">More...</a><br /></td></tr>
<tr class="separator:a3735268323742c7e078c8c30ebdea611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05330fa833db53d5cf7fae67890fb33e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a05330fa833db53d5cf7fae67890fb33e">set_body</a> (const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;body_data)</td></tr>
<tr class="memdesc:a05330fa833db53d5cf7fae67890fb33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to contain json value. If the 'Content-Type' header hasn't already been set it will be set to 'application/json'.  <a href="#a05330fa833db53d5cf7fae67890fb33e">More...</a><br /></td></tr>
<tr class="separator:a05330fa833db53d5cf7fae67890fb33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df4300099f1b1ee2fe69968280a3e60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a3df4300099f1b1ee2fe69968280a3e60">set_body</a> (std::vector&lt; unsigned char &gt; &amp;&amp;body_data)</td></tr>
<tr class="memdesc:a3df4300099f1b1ee2fe69968280a3e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'.  <a href="#a3df4300099f1b1ee2fe69968280a3e60">More...</a><br /></td></tr>
<tr class="separator:a3df4300099f1b1ee2fe69968280a3e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc99499f785b3e074d79c9370f1d847"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a4bc99499f785b3e074d79c9370f1d847">set_body</a> (const std::vector&lt; unsigned char &gt; &amp;body_data)</td></tr>
<tr class="memdesc:a4bc99499f785b3e074d79c9370f1d847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'.  <a href="#a4bc99499f785b3e074d79c9370f1d847">More...</a><br /></td></tr>
<tr class="separator:a4bc99499f785b3e074d79c9370f1d847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94076d78fd692d579a28b335a9c920f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a94076d78fd692d579a28b335a9c920f9">set_body</a> (const concurrency::streams::istream &amp;stream, const utility::string_t &amp;content_type=_XPLATSTR(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:a94076d78fd692d579a28b335a9c920f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to provide the body of the HTTP message when it is sent.  <a href="#a94076d78fd692d579a28b335a9c920f9">More...</a><br /></td></tr>
<tr class="separator:a94076d78fd692d579a28b335a9c920f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3929b2eb63efc64caacab71aa6bb273d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a3929b2eb63efc64caacab71aa6bb273d">set_body</a> (const concurrency::streams::istream &amp;stream, utility::size64_t content_length, const utility::string_t &amp;content_type=_XPLATSTR(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:a3929b2eb63efc64caacab71aa6bb273d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to provide the body of the HTTP message when it is sent.  <a href="#a3929b2eb63efc64caacab71aa6bb273d">More...</a><br /></td></tr>
<tr class="separator:a3929b2eb63efc64caacab71aa6bb273d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212c821976f2348adb406602a8f805d5"><td class="memItemLeft" align="right" valign="top">concurrency::streams::istream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a212c821976f2348adb406602a8f805d5">body</a> () const </td></tr>
<tr class="memdesc:a212c821976f2348adb406602a8f805d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a stream which the caller may use to retrieve data from an incoming request.  <a href="#a212c821976f2348adb406602a8f805d5">More...</a><br /></td></tr>
<tr class="separator:a212c821976f2348adb406602a8f805d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736e8f1158f806393d4dcad312939c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1http_1_1http__response.html">http::http_response</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a736e8f1158f806393d4dcad312939c06">content_ready</a> () const </td></tr>
<tr class="memdesc:a736e8f1158f806393d4dcad312939c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the user (client) when all the data for this response message has been received.  <a href="#a736e8f1158f806393d4dcad312939c06">More...</a><br /></td></tr>
<tr class="separator:a736e8f1158f806393d4dcad312939c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4906dde53ea224a4eb4e5d78ec87ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada4906dde53ea224a4eb4e5d78ec87ab"></a>
std::shared_ptr&lt; <a class="el" href="classweb_1_1http_1_1details_1_1__http__response.html">http::details::_http_response</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_get_impl</b> () const </td></tr>
<tr class="separator:ada4906dde53ea224a4eb4e5d78ec87ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fffb2afa471b3faa27d8d7a7310528"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69fffb2afa471b3faa27d8d7a7310528"></a>
<a class="el" href="classweb_1_1http_1_1details_1_1__http__server__context.html">http::details::_http_server_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_get_server_context</b> () const </td></tr>
<tr class="separator:a69fffb2afa471b3faa27d8d7a7310528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb6bbc8234ada5e5048e36e995b86a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacb6bbc8234ada5e5048e36e995b86a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_set_server_context</b> (std::unique_ptr&lt; <a class="el" href="classweb_1_1http_1_1details_1_1__http__server__context.html">http::details::_http_server_context</a> &gt; server_context)</td></tr>
<tr class="separator:aacb6bbc8234ada5e5048e36e995b86a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an HTTP response. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae2ee403657d29cc52abb94a7a9b0571c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_response::http_response </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a response with an empty status code, no headers, and no body. </p>
<dl class="section return"><dt>Returns</dt><dd>A new HTTP response.</dd></dl>

</div>
</div>
<a class="anchor" id="a91d11a840d30737505c614c82a716c06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_response::http_response </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a response with given status code, no headers, and no body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>HTTP status code to use in response.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new HTTP response.</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a212c821976f2348adb406602a8f805d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">concurrency::streams::istream web::http::http_response::body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces a stream which the caller may use to retrieve data from an incoming request. </p>
<dl class="section return"><dt>Returns</dt><dd>A readable, open asynchronous stream.</dd></dl>
<p>This cannot be used in conjunction with any other means of getting the body of the request. It is not necessary to wait until the message has been sent before starting to write to the stream, but it is advisable to do so, since it will allow the network I/O to start earlier and the work of sending data can be overlapped with the production of more data. </p>

</div>
</div>
<a class="anchor" id="a736e8f1158f806393d4dcad312939c06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1http_1_1http__response.html">http::http_response</a>&gt; web::http::http_response::content_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals the user (client) when all the data for this response message has been received. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> which is completed when all of the response body has been received.</dd></dl>

</div>
</div>
<a class="anchor" id="a2de616fedbe4b50ce5a67bce00675968"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1json_1_1value.html">json::value</a>&gt; web::http::http_response::extract_json </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_content_type</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the response message into a json value, checking that the content type is application/json. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_content_type</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON value from the body of this message.</dd></dl>

</div>
</div>
<a class="anchor" id="a1272e1a1e855c1433abd31a76ef3be97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;utility::string_t&gt; web::http::http_response::extract_string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_content_type</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the response message as a string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_content_type</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing body of the message.</dd></dl>

</div>
</div>
<a class="anchor" id="a99d4b658f735dfd922eb281e0e0b9217"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;utf16string&gt; web::http::http_response::extract_utf16string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_content_type</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the response message as a UTF-16 string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_content_type</td><td>If true, ignores the Content-Type header and assumes UTF-16.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing body of the message.</dd></dl>

</div>
</div>
<a class="anchor" id="a05d642c983c580aea8bcbe60dbe21bfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;utf8string&gt; web::http::http_response::extract_utf8string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_content_type</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the response message as a UTF-8 string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore_content_type</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing body of the message.</dd></dl>

</div>
</div>
<a class="anchor" id="a2dc26d0a1f79f0f31fdd6ec78a939cf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;std::vector&lt;unsigned char&gt; &gt; web::http::http_response::extract_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the response message into a vector of bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The body of the message as a vector of bytes.</dd></dl>

</div>
</div>
<a class="anchor" id="a88105e4a2ae4b71824346816ce8757af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a>&amp; web::http::http_response::headers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the headers of the response message. </p>
<dl class="section return"><dt>Returns</dt><dd>HTTP headers for this response.</dd></dl>
<p>Use the </p><dl class="section see"><dt>See also</dt><dd>http_headers::add Method</dd></dl>
<p>to fill in desired headers. </p>

</div>
</div>
<a class="anchor" id="ae9b24391efb8111ceb4f1f9396911a49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a>&amp; web::http::http_response::headers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a const reference to the headers of the response message. </p>
<dl class="section return"><dt>Returns</dt><dd>HTTP headers for this response.</dd></dl>

</div>
</div>
<a class="anchor" id="a926da1cf11129fd92c2c7919597fdead"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const http::reason_phrase&amp; web::http::http_response::reason_phrase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reason phrase of the response message. If no reason phrase is set it will default to the standard one corresponding to the status code. </p>
<dl class="section return"><dt>Returns</dt><dd>Reason phrase.</dd></dl>

</div>
</div>
<a class="anchor" id="aceb92b43a0d79024ebd658830baae155"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">utf8string &amp;&amp;&#160;</td>
          <td class="paramname"><em>body_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utf8string &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>utf8string(&quot;text/plain;&#160;charset=utf-8&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>String containing body text.</td></tr>
    <tr><td class="paramname">content_type</td><td>MIME type to set the "Content-Type" header to. Default to "text/plain; charset=utf-8".</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data and "Content-Type" header. </p>

</div>
</div>
<a class="anchor" id="a092bfc840766247d5f3a4971a0164418"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">const utf8string &amp;&#160;</td>
          <td class="paramname"><em>body_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utf8string &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>utf8string(&quot;text/plain;&#160;charset=utf-8&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>String containing body text.</td></tr>
    <tr><td class="paramname">content_type</td><td>MIME type to set the "Content-Type" header to. Default to "text/plain; charset=utf-8".</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data and "Content-Type" header. </p>

</div>
</div>
<a class="anchor" id="a3735268323742c7e078c8c30ebdea611"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">const utf16string &amp;&#160;</td>
          <td class="paramname"><em>body_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utf16string&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>::<a class="el" href="namespaceutility_1_1conversions.html#ac56351f05efb283401aac4249b816894">utility::conversions::to_utf16string</a>(&quot;text/plain&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is UTF-16 will perform conversion to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>String containing body text.</td></tr>
    <tr><td class="paramname">content_type</td><td>MIME type to set the "Content-Type" header to. Default to "text/plain".</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data and "Content-Type" header. </p>

</div>
</div>
<a class="anchor" id="a05330fa833db53d5cf7fae67890fb33e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to contain json value. If the 'Content-Type' header hasn't already been set it will be set to 'application/json'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>json value.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="a3df4300099f1b1ee2fe69968280a3e60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_data</td><td>Vector containing body data.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="a4bc99499f785b3e074d79c9370f1d847"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_data</td><td>Vector containing body data.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="a94076d78fd692d579a28b335a9c920f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">const concurrency::streams::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to provide the body of the HTTP message when it is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A readable, open asynchronous stream.</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
  </table>
  </dd>
</dl>
<p>This cannot be used in conjunction with any other means of setting the body of the request. The stream will not be read until the message is sent. </p>

</div>
</div>
<a class="anchor" id="a3929b2eb63efc64caacab71aa6bb273d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">const concurrency::streams::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>content_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to provide the body of the HTTP message when it is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A readable, open asynchronous stream.</td></tr>
    <tr><td class="paramname">content_length</td><td>The size of the data to be sent in the body.</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
  </table>
  </dd>
</dl>
<p>This cannot be used in conjunction with any other means of setting the body of the request. The stream will not be read until the message is sent. </p>

</div>
</div>
<a class="anchor" id="ab0bd6a4c59a88eabbc4318ad2483acb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_reason_phrase </td>
          <td>(</td>
          <td class="paramtype">const http::reason_phrase &amp;&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the reason phrase of the response message. If no reason phrase is set it will default to the standard one corresponding to the status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The reason phrase to set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17ecc55265b87f0749ba5ba7e3902233"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_status_code </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the status code of the response message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Status code to set.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set status code. </p>

</div>
</div>
<a class="anchor" id="a0ca073a1623724b450f56c5c3f9eb043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">http::status_code web::http::http_response::status_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the status code of the response message. </p>
<dl class="section return"><dt>Returns</dt><dd>status code.</dd></dl>

</div>
</div>
<a class="anchor" id="afe2e87b8b4aacdec1aad9a8f7c0baae9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">utility::string_t web::http::http_response::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string representation of the message, including the body when possible. Mainly this should be used for debugging purposes as it has to copy the message body and doesn't have excellent performance. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representation of this HTTP request.</dd></dl>
<p>Note this function is synchronous and doesn't wait for the entire message body to arrive. If the message body has arrived by the time this function is called and it is has a textual Content-Type it will be included. Otherwise just the headers will be present.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cpprest/<a class="el" href="http__msg_8h_source.html">http_msg.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
