<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>C++ Rest SDK: web::http::http_response Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">C++ Rest SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceweb.html">web</a></li><li class="navelem"><a class="el" href="namespaceweb_1_1http.html">http</a></li><li class="navelem"><a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classweb_1_1http_1_1http__response-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">web::http::http_response Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents an HTTP response.  
 <a href="classweb_1_1http_1_1http__response.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="http__msg_8h_source.html">http_msg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2ee403657d29cc52abb94a7a9b0571c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#ae2ee403657d29cc52abb94a7a9b0571c">http_response</a> ()</td></tr>
<tr class="memdesc:ae2ee403657d29cc52abb94a7a9b0571c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a response with an empty status code, no headers, and no body.  <a href="#ae2ee403657d29cc52abb94a7a9b0571c">More...</a><br /></td></tr>
<tr class="separator:ae2ee403657d29cc52abb94a7a9b0571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d11a840d30737505c614c82a716c06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a91d11a840d30737505c614c82a716c06">http_response</a> (http::status_code code)</td></tr>
<tr class="memdesc:a91d11a840d30737505c614c82a716c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a response with given status code, no headers, and no body.  <a href="#a91d11a840d30737505c614c82a716c06">More...</a><br /></td></tr>
<tr class="separator:a91d11a840d30737505c614c82a716c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f85056aa759dcbaa1eed8280ead3d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#ae6f85056aa759dcbaa1eed8280ead3d0">http_response</a> (const <a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> &amp;response)</td></tr>
<tr class="memdesc:ae6f85056aa759dcbaa1eed8280ead3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ae6f85056aa759dcbaa1eed8280ead3d0">More...</a><br /></td></tr>
<tr class="separator:ae6f85056aa759dcbaa1eed8280ead3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5370e03a31c2e38d17a6246ff49ed69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#aa5370e03a31c2e38d17a6246ff49ed69">operator=</a> (const <a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> &amp;response)</td></tr>
<tr class="memdesc:aa5370e03a31c2e38d17a6246ff49ed69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#aa5370e03a31c2e38d17a6246ff49ed69">More...</a><br /></td></tr>
<tr class="separator:aa5370e03a31c2e38d17a6246ff49ed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca073a1623724b450f56c5c3f9eb043"><td class="memItemLeft" align="right" valign="top">http::status_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a0ca073a1623724b450f56c5c3f9eb043">status_code</a> () const </td></tr>
<tr class="memdesc:a0ca073a1623724b450f56c5c3f9eb043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the status code of the response message.  <a href="#a0ca073a1623724b450f56c5c3f9eb043">More...</a><br /></td></tr>
<tr class="separator:a0ca073a1623724b450f56c5c3f9eb043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ecc55265b87f0749ba5ba7e3902233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a17ecc55265b87f0749ba5ba7e3902233">set_status_code</a> (http::status_code code) const </td></tr>
<tr class="memdesc:a17ecc55265b87f0749ba5ba7e3902233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the status code of the response message.  <a href="#a17ecc55265b87f0749ba5ba7e3902233">More...</a><br /></td></tr>
<tr class="separator:a17ecc55265b87f0749ba5ba7e3902233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926da1cf11129fd92c2c7919597fdead"><td class="memItemLeft" align="right" valign="top">const http::reason_phrase &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a926da1cf11129fd92c2c7919597fdead">reason_phrase</a> () const </td></tr>
<tr class="memdesc:a926da1cf11129fd92c2c7919597fdead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reason phrase of the response message. If no reason phrase is set it will default to the standard one corresponding to the status code.  <a href="#a926da1cf11129fd92c2c7919597fdead">More...</a><br /></td></tr>
<tr class="separator:a926da1cf11129fd92c2c7919597fdead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a784efaf8dfe880a292a62371f0d5b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a1a784efaf8dfe880a292a62371f0d5b0">set_reason_phrase</a> (http::reason_phrase reason) const </td></tr>
<tr class="memdesc:a1a784efaf8dfe880a292a62371f0d5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reason phrase of the response message. If no reason phrase is set it will default to the standard one corresponding to the status code.  <a href="#a1a784efaf8dfe880a292a62371f0d5b0">More...</a><br /></td></tr>
<tr class="separator:a1a784efaf8dfe880a292a62371f0d5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88105e4a2ae4b71824346816ce8757af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a88105e4a2ae4b71824346816ce8757af">headers</a> ()</td></tr>
<tr class="memdesc:a88105e4a2ae4b71824346816ce8757af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the headers of the response message.  <a href="#a88105e4a2ae4b71824346816ce8757af">More...</a><br /></td></tr>
<tr class="separator:a88105e4a2ae4b71824346816ce8757af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b24391efb8111ceb4f1f9396911a49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9b24391efb8111ceb4f1f9396911a49"></a>
const <a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>headers</b> () const </td></tr>
<tr class="separator:ae9b24391efb8111ceb4f1f9396911a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2e87b8b4aacdec1aad9a8f7c0baae9"><td class="memItemLeft" align="right" valign="top">utility::string_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#afe2e87b8b4aacdec1aad9a8f7c0baae9">to_string</a> () const </td></tr>
<tr class="memdesc:afe2e87b8b4aacdec1aad9a8f7c0baae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string representation of the message, including the body when possible.  <a href="#afe2e87b8b4aacdec1aad9a8f7c0baae9">More...</a><br /></td></tr>
<tr class="separator:afe2e87b8b4aacdec1aad9a8f7c0baae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e27c5454d16545685074faa1dae96b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; utility::string_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a93e27c5454d16545685074faa1dae96b">extract_string</a> (bool force=false) const </td></tr>
<tr class="memdesc:a93e27c5454d16545685074faa1dae96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the response message as a string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#a93e27c5454d16545685074faa1dae96b">More...</a><br /></td></tr>
<tr class="separator:a93e27c5454d16545685074faa1dae96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5faaf7c525d09c6b2035e646c0b72df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#ae5faaf7c525d09c6b2035e646c0b72df">extract_json</a> (bool force=false) const </td></tr>
<tr class="memdesc:ae5faaf7c525d09c6b2035e646c0b72df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the response message into a json value, checking that the content type is application. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out.  <a href="#ae5faaf7c525d09c6b2035e646c0b72df">More...</a><br /></td></tr>
<tr class="separator:ae5faaf7c525d09c6b2035e646c0b72df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc26d0a1f79f0f31fdd6ec78a939cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; std::vector<br class="typebreak" />
&lt; unsigned char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a2dc26d0a1f79f0f31fdd6ec78a939cf0">extract_vector</a> () const </td></tr>
<tr class="memdesc:a2dc26d0a1f79f0f31fdd6ec78a939cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the body of the response message into a vector of bytes.  <a href="#a2dc26d0a1f79f0f31fdd6ec78a939cf0">More...</a><br /></td></tr>
<tr class="separator:a2dc26d0a1f79f0f31fdd6ec78a939cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706671444f6758ba58e24700884a6ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a706671444f6758ba58e24700884a6ac7">set_body</a> (const utility::string_t &amp;body_text, utility::string_t content_type=utility::string_t(_XPLATSTR(&quot;text/plain&quot;)))</td></tr>
<tr class="memdesc:a706671444f6758ba58e24700884a6ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is the OS's default code page and will perform appropriate conversions to UTF-8.  <a href="#a706671444f6758ba58e24700884a6ac7">More...</a><br /></td></tr>
<tr class="separator:a706671444f6758ba58e24700884a6ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05330fa833db53d5cf7fae67890fb33e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a05330fa833db53d5cf7fae67890fb33e">set_body</a> (const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;body_data)</td></tr>
<tr class="memdesc:a05330fa833db53d5cf7fae67890fb33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to contain json value. If the 'Content-Type' header hasn't already been set it will be set to 'application/json'.  <a href="#a05330fa833db53d5cf7fae67890fb33e">More...</a><br /></td></tr>
<tr class="separator:a05330fa833db53d5cf7fae67890fb33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821139b6e61cb2c9a004c6976eac980a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a821139b6e61cb2c9a004c6976eac980a">set_body</a> (std::vector&lt; unsigned char &gt; body_data)</td></tr>
<tr class="memdesc:a821139b6e61cb2c9a004c6976eac980a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'.  <a href="#a821139b6e61cb2c9a004c6976eac980a">More...</a><br /></td></tr>
<tr class="separator:a821139b6e61cb2c9a004c6976eac980a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb0546333847fb7d6f0df196198f630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a2fb0546333847fb7d6f0df196198f630">set_body</a> (concurrency::streams::istream stream, utility::string_t content_type=_XPLATSTR(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:a2fb0546333847fb7d6f0df196198f630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to provide the body of the HTTP message when it is sent.  <a href="#a2fb0546333847fb7d6f0df196198f630">More...</a><br /></td></tr>
<tr class="separator:a2fb0546333847fb7d6f0df196198f630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a04b96c6c89f58e4ba2ef3ec5515040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a3a04b96c6c89f58e4ba2ef3ec5515040">set_body</a> (concurrency::streams::istream stream, utility::size64_t content_length, utility::string_t content_type=_XPLATSTR(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:a3a04b96c6c89f58e4ba2ef3ec5515040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a stream that will be relied on to provide the body of the HTTP message when it is sent.  <a href="#a3a04b96c6c89f58e4ba2ef3ec5515040">More...</a><br /></td></tr>
<tr class="separator:a3a04b96c6c89f58e4ba2ef3ec5515040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212c821976f2348adb406602a8f805d5"><td class="memItemLeft" align="right" valign="top">concurrency::streams::istream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a212c821976f2348adb406602a8f805d5">body</a> () const </td></tr>
<tr class="memdesc:a212c821976f2348adb406602a8f805d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a stream which the caller may use to retrieve data from an incoming request.  <a href="#a212c821976f2348adb406602a8f805d5">More...</a><br /></td></tr>
<tr class="separator:a212c821976f2348adb406602a8f805d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736e8f1158f806393d4dcad312939c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; <a class="el" href="classweb_1_1http_1_1http__response.html">http::http_response</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classweb_1_1http_1_1http__response.html#a736e8f1158f806393d4dcad312939c06">content_ready</a> () const </td></tr>
<tr class="memdesc:a736e8f1158f806393d4dcad312939c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the user (client) when all the data for this response message has been received.  <a href="#a736e8f1158f806393d4dcad312939c06">More...</a><br /></td></tr>
<tr class="separator:a736e8f1158f806393d4dcad312939c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an HTTP response. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae2ee403657d29cc52abb94a7a9b0571c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_response::http_response </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a response with an empty status code, no headers, and no body. </p>
<dl class="section return"><dt>Returns</dt><dd>A new HTTP response.</dd></dl>

</div>
</div>
<a class="anchor" id="a91d11a840d30737505c614c82a716c06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_response::http_response </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a response with given status code, no headers, and no body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>HTTP status code to use in response.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new HTTP response.</dd></dl>

</div>
</div>
<a class="anchor" id="ae6f85056aa759dcbaa1eed8280ead3d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">web::http::http_response::http_response </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">response</td><td>The <a class="el" href="classweb_1_1http_1_1http__response.html" title="Represents an HTTP response. ">http_response</a> to copy from.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a212c821976f2348adb406602a8f805d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">concurrency::streams::istream web::http::http_response::body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces a stream which the caller may use to retrieve data from an incoming request. </p>
<dl class="section return"><dt>Returns</dt><dd>A readable, open asynchronous stream.</dd></dl>
<p>This cannot be used in conjunction with any other means of getting the body of the request. It is not necessary to wait until the message has been sent before starting to write to the stream, but it is advisable to do so, since it will allow the network I/O to start earlier and the work of sending data can be overlapped with the production of more data. </p>

</div>
</div>
<a class="anchor" id="a736e8f1158f806393d4dcad312939c06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1http_1_1http__response.html">http::http_response</a>&gt; web::http::http_response::content_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signals the user (client) when all the data for this response message has been received. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> which is completed when all of the response body has been received.</dd></dl>

</div>
</div>
<a class="anchor" id="ae5faaf7c525d09c6b2035e646c0b72df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;<a class="el" href="classweb_1_1json_1_1value.html">json::value</a>&gt; web::http::http_response::extract_json </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the response message into a json value, checking that the content type is application. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON value from the body of this message.</dd></dl>

</div>
</div>
<a class="anchor" id="a93e27c5454d16545685074faa1dae96b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;utility::string_t&gt; web::http::http_response::extract_string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the response message as a string value, checking that the content type is a MIME text type. A body can only be extracted once because in some cases an optimization is made where the data is 'moved' out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>If true, ignores the Content-Type header and assumes UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing body of the message.</dd></dl>

</div>
</div>
<a class="anchor" id="a2dc26d0a1f79f0f31fdd6ec78a939cf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;std::vector&lt;unsigned char&gt; &gt; web::http::http_response::extract_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the body of the response message into a vector of bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The body of the message as a vector of bytes.</dd></dl>

</div>
</div>
<a class="anchor" id="a88105e4a2ae4b71824346816ce8757af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1http_1_1http__headers.html">http_headers</a>&amp; web::http::http_response::headers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the headers of the response message. </p>
<dl class="section return"><dt>Returns</dt><dd>HTTP headers for this response.</dd></dl>
<p>Use the </p><dl class="section see"><dt>See also</dt><dd>http_headers::add Method</dd></dl>
<p>to fill in desired headers. </p>

</div>
</div>
<a class="anchor" id="aa5370e03a31c2e38d17a6246ff49ed69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a>&amp; web::http::http_response::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1http_1_1http__response.html">http_response</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>

</div>
</div>
<a class="anchor" id="a926da1cf11129fd92c2c7919597fdead"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const http::reason_phrase&amp; web::http::http_response::reason_phrase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reason phrase of the response message. If no reason phrase is set it will default to the standard one corresponding to the status code. </p>
<dl class="section return"><dt>Returns</dt><dd>Reason phrase.</dd></dl>

</div>
</div>
<a class="anchor" id="a706671444f6758ba58e24700884a6ac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">const utility::string_t &amp;&#160;</td>
          <td class="paramname"><em>body_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>utility::string_t(_XPLATSTR(&quot;text/plain&quot;))</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to a textual string and set the "Content-Type" header. Assumes the character encoding of the string is the OS's default code page and will perform appropriate conversions to UTF-8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>String containing body text.</td></tr>
    <tr><td class="paramname">content_type</td><td>MIME type to set the "Content-Type" header to. Default to "text/plain".</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data and "Content-Type" header. </p>

</div>
</div>
<a class="anchor" id="a05330fa833db53d5cf7fae67890fb33e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classweb_1_1json_1_1value.html">json::value</a> &amp;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to contain json value. If the 'Content-Type' header hasn't already been set it will be set to 'application/json'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_text</td><td>json value.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="a821139b6e61cb2c9a004c6976eac980a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>body_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the body of the message to the contents of a byte vector. If the 'Content-Type' header hasn't already been set it will be set to 'application/octet-stream'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_data</td><td>Vector containing body data.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set body data. </p>

</div>
</div>
<a class="anchor" id="a2fb0546333847fb7d6f0df196198f630"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to provide the body of the HTTP message when it is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A readable, open asynchronous stream.</td></tr>
  </table>
  </dd>
</dl>
<p>This cannot be used in conjunction with any other means of setting the body of the request. The stream will not be read until the message is sent. </p>

</div>
</div>
<a class="anchor" id="a3a04b96c6c89f58e4ba2ef3ec5515040"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_body </td>
          <td>(</td>
          <td class="paramtype">concurrency::streams::istream&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::size64_t&#160;</td>
          <td class="paramname"><em>content_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utility::string_t&#160;</td>
          <td class="paramname"><em>content_type</em> = <code>_XPLATSTR(&quot;application/octet-stream&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a stream that will be relied on to provide the body of the HTTP message when it is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A readable, open asynchronous stream.</td></tr>
    <tr><td class="paramname">content_length</td><td>The size of the data to be sent in the body.</td></tr>
    <tr><td class="paramname">content_type</td><td>A string holding the MIME type of the message body.</td></tr>
  </table>
  </dd>
</dl>
<p>This cannot be used in conjunction with any other means of setting the body of the request. The stream will not be read until the message is sent. </p>

</div>
</div>
<a class="anchor" id="a1a784efaf8dfe880a292a62371f0d5b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_reason_phrase </td>
          <td>(</td>
          <td class="paramtype">http::reason_phrase&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the reason phrase of the response message. If no reason phrase is set it will default to the standard one corresponding to the status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The reason phrase to set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17ecc55265b87f0749ba5ba7e3902233"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void web::http::http_response::set_status_code </td>
          <td>(</td>
          <td class="paramtype">http::status_code&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the status code of the response message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Status code to set.</td></tr>
  </table>
  </dd>
</dl>
<p>This will overwrite any previously set status code. </p>

</div>
</div>
<a class="anchor" id="a0ca073a1623724b450f56c5c3f9eb043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">http::status_code web::http::http_response::status_code </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the status code of the response message. </p>
<dl class="section return"><dt>Returns</dt><dd>status code.</dd></dl>

</div>
</div>
<a class="anchor" id="afe2e87b8b4aacdec1aad9a8f7c0baae9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">utility::string_t web::http::http_response::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a string representation of the message, including the body when possible. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representation of this HTTP request.</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cpprest/<a class="el" href="http__msg_8h_source.html">http_msg.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 19 2014 16:17:55 for C++ Rest SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
