<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>C++ Rest SDK: pplx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">C++ Rest SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pplx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <code>pplx</code> namespace provides classes and functions that give you access to the Concurrency Runtime, a concurrent programming framework for C++. For more information, see Concurrency Runtime.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>_Continuation_func_transformer</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class template that transforms a continuation lambda that either takes or returns void, or both, into a lambda that takes and returns a non-void type (details::_Unit_type is used to substitute for void). This is to minimize the special handling required for 'void'. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>_Continuation_func_transformer&lt; _InType, void &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>_Continuation_func_transformer&lt; void, _OutType &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>_Continuation_func_transformer&lt; void, void &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>_Init_func_transformer</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>_Init_func_transformer&lt; void &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1cancellation__token.html">cancellation_token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classpplx_1_1cancellation__token.html" title="The cancellation_token class represents the ability to determine whether some operation has been requ...">cancellation_token</a></code> class represents the ability to determine whether some operation has been requested to cancel. A given token can be associated with a <code>task_group</code>, <code>structured_task_group</code>, or <code>task</code> to provide implicit cancellation. It can also be polled for cancellation or have a callback registered for if and when the associated <code><a class="el" href="classpplx_1_1cancellation__token__source.html" title="The cancellation_token_source class represents the ability to cancel some cancelable operation...">cancellation_token_source</a></code> is canceled.  <a href="classpplx_1_1cancellation__token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1cancellation__token__registration.html">cancellation_token_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classpplx_1_1cancellation__token__registration.html" title="The cancellation_token_registration class represents a callback notification from a cancellation_toke...">cancellation_token_registration</a></code> class represents a callback notification from a <code><a class="el" href="classpplx_1_1cancellation__token.html" title="The cancellation_token class represents the ability to determine whether some operation has been requ...">cancellation_token</a></code>. When the <code>register</code> method on a <code><a class="el" href="classpplx_1_1cancellation__token.html" title="The cancellation_token class represents the ability to determine whether some operation has been requ...">cancellation_token</a></code> is used to receive notification of when cancellation occurs, a <code><a class="el" href="classpplx_1_1cancellation__token__registration.html" title="The cancellation_token_registration class represents a callback notification from a cancellation_toke...">cancellation_token_registration</a></code> object is returned as a handle to the callback so that the caller can request a specific callback no longer be made through use of the <code>deregister</code> method.  <a href="classpplx_1_1cancellation__token__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1cancellation__token__source.html">cancellation_token_source</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classpplx_1_1cancellation__token__source.html" title="The cancellation_token_source class represents the ability to cancel some cancelable operation...">cancellation_token_source</a></code> class represents the ability to cancel some cancelable operation.  <a href="classpplx_1_1cancellation__token__source.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1invalid__operation.html">invalid_operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes an exception thrown when an invalid operation is performed that is not more accurately described by another exception type thrown by the Concurrency Runtime.  <a href="classpplx_1_1invalid__operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpplx_1_1scheduler__ptr.html">scheduler_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pointer to a scheduler. This class exists to allow the the specification of a shared lifetime by using shared_ptr or just a plain reference by using raw pointer.  <a href="structpplx_1_1scheduler__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1scoped__lock.html">scoped_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic RAII wrapper for locks that implements the critical_section interface cpprest_synchronization::lock_guard  <a href="classpplx_1_1scoped__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1task.html">task</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Parallel Patterns Library (PPL) <code>task</code> class. A <code>task</code> object represents work that can be executed asynchronously, and concurrently with other tasks and parallel work produced by parallel algorithms in the Concurrency Runtime. It produces a result of type <em>_ResultType</em>  on successful completion. Tasks of type <code>task&lt;void&gt;</code> produce no result. A task can be waited upon and canceled independently of other tasks. It can also be composed with other tasks using continuations(<code>then</code>), and join(<code>when_all</code>) and choice(<code>when_any</code>) patterns.  <a href="classpplx_1_1task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1task_3_01void_01_4.html">task&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Parallel Patterns Library (PPL) <code>task</code> class. A <code>task</code> object represents work that can be executed asynchronously, and concurrently with other tasks and parallel work produced by parallel algorithms in the Concurrency Runtime. It produces a result of type <em>_ResultType</em>  on successful completion. Tasks of type <code>task&lt;void&gt;</code> produce no result. A task can be waited upon and canceled independently of other tasks. It can also be composed with other tasks using continuations(<code>then</code>), and join(<code>when_all</code>) and choice(<code>when_any</code>) patterns.  <a href="classpplx_1_1task_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1task__canceled.html">task_canceled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes an exception thrown by the PPL tasks layer in order to force the current task to cancel. It is also thrown by the <code>get()</code> method on <a class="el" href="">task</a>, for a canceled task.  <a href="classpplx_1_1task__canceled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1task__completion__event.html">task_completion_event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classpplx_1_1task__completion__event.html" title="The task_completion_event class allows you to delay the execution of a task until a condition is sati...">task_completion_event</a></code> class allows you to delay the execution of a task until a condition is satisfied, or start a task in response to an external event.  <a href="classpplx_1_1task__completion__event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1task__completion__event_3_01void_01_4.html">task_completion_event&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classpplx_1_1task__completion__event.html" title="The task_completion_event class allows you to delay the execution of a task until a condition is sati...">task_completion_event</a></code> class allows you to delay the execution of a task until a condition is satisfied, or start a task in response to an external event.  <a href="classpplx_1_1task__completion__event_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1task__continuation__context.html">task_continuation_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classpplx_1_1task__continuation__context.html" title="The task_continuation_context class allows you to specify where you would like a continuation to be e...">task_continuation_context</a></code> class allows you to specify where you would like a continuation to be executed. It is only useful to use this class from a Windows Store app. For non-Windows Store apps, the task continuation's execution context is determined by the runtime, and not configurable.  <a href="classpplx_1_1task__continuation__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpplx_1_1task__options.html">task_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the allowed options for creating a task  <a href="classpplx_1_1task__options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac172757ccc22c3e784c086cc3792863c"><td class="memItemLeft" align="right" valign="top">typedef void(_pplx_cdecl *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepplx.html#ac172757ccc22c3e784c086cc3792863c">TaskProc_t</a> )(void *)</td></tr>
<tr class="memdesc:ac172757ccc22c3e784c086cc3792863c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An elementary abstraction for a task, defined as <code>void (__cdecl * TaskProc_t)(void *)</code>. A <code>TaskProc</code> is called to invoke the body of a task.  <a href="#ac172757ccc22c3e784c086cc3792863c">More...</a><br /></td></tr>
<tr class="separator:ac172757ccc22c3e784c086cc3792863c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3f734bd9b91ceed71bacf4ae1fee6a"><td class="memItemLeft" align="right" valign="top">typedef details::linux_scheduler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a8f3f734bd9b91ceed71bacf4ae1fee6a">default_scheduler_t</a></td></tr>
<tr class="memdesc:a8f3f734bd9b91ceed71bacf4ae1fee6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default scheduler type  <a href="#a8f3f734bd9b91ceed71bacf4ae1fee6a">More...</a><br /></td></tr>
<tr class="separator:a8f3f734bd9b91ceed71bacf4ae1fee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44290e93feb32970ccf02e7bdb5672b6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacepplx.html#a7569c24382f33970242029beed764a6e">task_group_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a44290e93feb32970ccf02e7bdb5672b6">task_status</a></td></tr>
<tr class="memdesc:a44290e93feb32970ccf02e7bdb5672b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that represents the terminal state of a task. Valid values are <code>completed</code> and <code>canceled</code>.  <a href="#a44290e93feb32970ccf02e7bdb5672b6">More...</a><br /></td></tr>
<tr class="separator:a44290e93feb32970ccf02e7bdb5672b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7569c24382f33970242029beed764a6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a7569c24382f33970242029beed764a6e">task_group_status</a> { <a class="el" href="namespacepplx.html#a7569c24382f33970242029beed764a6ea716faa59dcf6afa0531293efd19eba46">not_complete</a>, 
<a class="el" href="namespacepplx.html#a7569c24382f33970242029beed764a6ea87039ec3b562b36fda8b3182cc8c833d">completed</a>, 
<a class="el" href="namespacepplx.html#a7569c24382f33970242029beed764a6eab75a9c53022cfdf92b382692f6576462">canceled</a>
 }</td></tr>
<tr class="memdesc:a7569c24382f33970242029beed764a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the execution status of a <code>task_group</code> or <code>structured_task_group</code> object. A value of this type is returned by numerous methods that wait on tasks scheduled to a task group to complete.  <a href="namespacepplx.html#a7569c24382f33970242029beed764a6e">More...</a><br /></td></tr>
<tr class="separator:a7569c24382f33970242029beed764a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac98993a43756c17916a9a14d89f1ca05"><td class="memItemLeft" align="right" valign="top">_PPLXIMP void _pplx_cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepplx.html#ac98993a43756c17916a9a14d89f1ca05">set_ambient_scheduler</a> (std::shared_ptr&lt; pplx::scheduler_interface &gt; _Scheduler)</td></tr>
<tr class="memdesc:ac98993a43756c17916a9a14d89f1ca05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ambient scheduler to be used by the PPL constructs.  <a href="#ac98993a43756c17916a9a14d89f1ca05">More...</a><br /></td></tr>
<tr class="separator:ac98993a43756c17916a9a14d89f1ca05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09b7c5b825a72cdf4f6b59e73e6ba3b"><td class="memItemLeft" align="right" valign="top">_PPLXIMP std::shared_ptr<br class="typebreak" />
&lt; pplx::scheduler_interface &gt;<br class="typebreak" />
 _pplx_cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepplx.html#ac09b7c5b825a72cdf4f6b59e73e6ba3b">get_ambient_scheduler</a> ()</td></tr>
<tr class="memdesc:ac09b7c5b825a72cdf4f6b59e73e6ba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ambient scheduler to be used by the PPL constructs  <a href="#ac09b7c5b825a72cdf4f6b59e73e6ba3b">More...</a><br /></td></tr>
<tr class="separator:ac09b7c5b825a72cdf4f6b59e73e6ba3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2429fe4b49957feae53b2dee7077455"><td class="memItemLeft" align="right" valign="top">bool _pplx_cdecl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepplx.html#aa2429fe4b49957feae53b2dee7077455">is_task_cancellation_requested</a> ()</td></tr>
<tr class="memdesc:aa2429fe4b49957feae53b2dee7077455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an indication of whether the task that is currently executing has received a request to cancel its execution. Cancellation is requested on a task if the task was created with a cancellation token, and the token source associated with that token is canceled.  <a href="#aa2429fe4b49957feae53b2dee7077455">More...</a><br /></td></tr>
<tr class="separator:aa2429fe4b49957feae53b2dee7077455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dcfa2f691ee1f2176157a485bfca01"><td class="memTemplParams" colspan="2">template&lt;typename _Iterator &gt; </td></tr>
<tr class="memitem:ae4dcfa2f691ee1f2176157a485bfca01"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#ae4dcfa2f691ee1f2176157a485bfca01">when_all</a> (_Iterator _Begin, _Iterator _End, const <a class="el" href="classpplx_1_1task__options.html">task_options</a> &amp;_TaskOptions=<a class="el" href="classpplx_1_1task__options.html">task_options</a>()) -&gt; decltype(details::_WhenAllImpl&lt; typename std::iterator_traits&lt; _Iterator &gt;::value_type::result_type, _Iterator &gt;::_Perform(_TaskOptions, _Begin, _End))</td></tr>
<tr class="memdesc:ae4dcfa2f691ee1f2176157a485bfca01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete successfully when all of the tasks supplied as arguments complete successfully.  <a href="#ae4dcfa2f691ee1f2176157a485bfca01">More...</a><br /></td></tr>
<tr class="separator:ae4dcfa2f691ee1f2176157a485bfca01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c24f824352abd1b423a019bfbef9eb1"><td class="memTemplParams" colspan="2">template&lt;typename _ReturnType &gt; </td></tr>
<tr class="memitem:a1c24f824352abd1b423a019bfbef9eb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a1c24f824352abd1b423a019bfbef9eb1">operator&amp;&amp;</a> (const <a class="el" href="classpplx_1_1task.html">task</a>&lt; _ReturnType &gt; &amp;_Lhs, const <a class="el" href="classpplx_1_1task.html">task</a>&lt; _ReturnType &gt; &amp;_Rhs)</td></tr>
<tr class="memdesc:a1c24f824352abd1b423a019bfbef9eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully.  <a href="#a1c24f824352abd1b423a019bfbef9eb1">More...</a><br /></td></tr>
<tr class="separator:a1c24f824352abd1b423a019bfbef9eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429e1963234b9b28f1747c8c997e10f7"><td class="memTemplParams" colspan="2">template&lt;typename _ReturnType &gt; </td></tr>
<tr class="memitem:a429e1963234b9b28f1747c8c997e10f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a429e1963234b9b28f1747c8c997e10f7">operator&amp;&amp;</a> (const <a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;_Lhs, const <a class="el" href="classpplx_1_1task.html">task</a>&lt; _ReturnType &gt; &amp;_Rhs)</td></tr>
<tr class="memdesc:a429e1963234b9b28f1747c8c997e10f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully.  <a href="#a429e1963234b9b28f1747c8c997e10f7">More...</a><br /></td></tr>
<tr class="separator:a429e1963234b9b28f1747c8c997e10f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6d84b73341f2de8a9d13b4e1fe3c11"><td class="memTemplParams" colspan="2">template&lt;typename _ReturnType &gt; </td></tr>
<tr class="memitem:a2c6d84b73341f2de8a9d13b4e1fe3c11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a2c6d84b73341f2de8a9d13b4e1fe3c11">operator&amp;&amp;</a> (const <a class="el" href="classpplx_1_1task.html">task</a>&lt; _ReturnType &gt; &amp;_Lhs, const <a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;_Rhs)</td></tr>
<tr class="memdesc:a2c6d84b73341f2de8a9d13b4e1fe3c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully.  <a href="#a2c6d84b73341f2de8a9d13b4e1fe3c11">More...</a><br /></td></tr>
<tr class="separator:a2c6d84b73341f2de8a9d13b4e1fe3c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae533af5e9740e765bdac4971edff9642"><td class="memTemplParams" colspan="2">template&lt;typename _ReturnType &gt; </td></tr>
<tr class="memitem:ae533af5e9740e765bdac4971edff9642"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#ae533af5e9740e765bdac4971edff9642">operator&amp;&amp;</a> (const <a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;_Lhs, const <a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;_Rhs)</td></tr>
<tr class="memdesc:ae533af5e9740e765bdac4971edff9642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully.  <a href="#ae533af5e9740e765bdac4971edff9642">More...</a><br /></td></tr>
<tr class="separator:ae533af5e9740e765bdac4971edff9642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0e1abb32fe51d8cf4af446a32c069d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a3c0e1abb32fe51d8cf4af446a32c069d">operator&amp;&amp;</a> (const <a class="el" href="classpplx_1_1task.html">task</a>&lt; void &gt; &amp;_Lhs, const <a class="el" href="classpplx_1_1task.html">task</a>&lt; void &gt; &amp;_Rhs)</td></tr>
<tr class="memdesc:a3c0e1abb32fe51d8cf4af446a32c069d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully.  <a href="#a3c0e1abb32fe51d8cf4af446a32c069d">More...</a><br /></td></tr>
<tr class="separator:a3c0e1abb32fe51d8cf4af446a32c069d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab497ff57fed159d56367d8098dd3324a"><td class="memTemplParams" colspan="2">template&lt;typename _Iterator &gt; </td></tr>
<tr class="memitem:ab497ff57fed159d56367d8098dd3324a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#ab497ff57fed159d56367d8098dd3324a">when_any</a> (_Iterator _Begin, _Iterator _End, const <a class="el" href="classpplx_1_1task__options.html">task_options</a> &amp;_TaskOptions=<a class="el" href="classpplx_1_1task__options.html">task_options</a>()) -&gt; decltype(details::_WhenAnyImpl&lt; typename std::iterator_traits&lt; _Iterator &gt;::value_type::result_type, _Iterator &gt;::_Perform(_TaskOptions, _Begin, _End))</td></tr>
<tr class="memdesc:ab497ff57fed159d56367d8098dd3324a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully.  <a href="#ab497ff57fed159d56367d8098dd3324a">More...</a><br /></td></tr>
<tr class="separator:ab497ff57fed159d56367d8098dd3324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009f35ac6af0b829b593f9d705a5ca09"><td class="memTemplParams" colspan="2">template&lt;typename _Iterator &gt; </td></tr>
<tr class="memitem:a009f35ac6af0b829b593f9d705a5ca09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a009f35ac6af0b829b593f9d705a5ca09">when_any</a> (_Iterator _Begin, _Iterator _End, <a class="el" href="classpplx_1_1cancellation__token.html">cancellation_token</a> _CancellationToken) -&gt; decltype(details::_WhenAnyImpl&lt; typename std::iterator_traits&lt; _Iterator &gt;::value_type::result_type, _Iterator &gt;::_Perform(_CancellationToken._GetImplValue(), _Begin, _End))</td></tr>
<tr class="memdesc:a009f35ac6af0b829b593f9d705a5ca09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully.  <a href="#a009f35ac6af0b829b593f9d705a5ca09">More...</a><br /></td></tr>
<tr class="separator:a009f35ac6af0b829b593f9d705a5ca09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818b80cadb056b8b12094997af6ba88d"><td class="memTemplParams" colspan="2">template&lt;typename _ReturnType &gt; </td></tr>
<tr class="memitem:a818b80cadb056b8b12094997af6ba88d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; _ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a818b80cadb056b8b12094997af6ba88d">operator||</a> (const <a class="el" href="classpplx_1_1task.html">task</a>&lt; _ReturnType &gt; &amp;_Lhs, const <a class="el" href="classpplx_1_1task.html">task</a>&lt; _ReturnType &gt; &amp;_Rhs)</td></tr>
<tr class="memdesc:a818b80cadb056b8b12094997af6ba88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete successfully when either of the tasks supplied as arguments completes successfully.  <a href="#a818b80cadb056b8b12094997af6ba88d">More...</a><br /></td></tr>
<tr class="separator:a818b80cadb056b8b12094997af6ba88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4e16c30c13c3d9663e1ca4be0a072c"><td class="memTemplParams" colspan="2">template&lt;typename _ReturnType &gt; </td></tr>
<tr class="memitem:aaa4e16c30c13c3d9663e1ca4be0a072c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#aaa4e16c30c13c3d9663e1ca4be0a072c">operator||</a> (const <a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;_Lhs, const <a class="el" href="classpplx_1_1task.html">task</a>&lt; _ReturnType &gt; &amp;_Rhs)</td></tr>
<tr class="memdesc:aaa4e16c30c13c3d9663e1ca4be0a072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully.  <a href="#aaa4e16c30c13c3d9663e1ca4be0a072c">More...</a><br /></td></tr>
<tr class="separator:aaa4e16c30c13c3d9663e1ca4be0a072c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dac155b3fc42aeee13defc82d97fe9"><td class="memTemplParams" colspan="2">template&lt;typename _ReturnType &gt; </td></tr>
<tr class="memitem:ae1dac155b3fc42aeee13defc82d97fe9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepplx.html#ae1dac155b3fc42aeee13defc82d97fe9">operator||</a> (const <a class="el" href="classpplx_1_1task.html">task</a>&lt; _ReturnType &gt; &amp;_Lhs, const <a class="el" href="classpplx_1_1task.html">task</a>&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;_Rhs)</td></tr>
<tr class="memdesc:ae1dac155b3fc42aeee13defc82d97fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully.  <a href="#ae1dac155b3fc42aeee13defc82d97fe9">More...</a><br /></td></tr>
<tr class="separator:ae1dac155b3fc42aeee13defc82d97fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb8a11095a9d84b4e1b4af279050127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepplx.html#a0eb8a11095a9d84b4e1b4af279050127">operator||</a> (const <a class="el" href="classpplx_1_1task.html">task</a>&lt; void &gt; &amp;_Lhs, const <a class="el" href="classpplx_1_1task.html">task</a>&lt; void &gt; &amp;_Rhs)</td></tr>
<tr class="memdesc:a0eb8a11095a9d84b4e1b4af279050127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully.  <a href="#a0eb8a11095a9d84b4e1b4af279050127">More...</a><br /></td></tr>
<tr class="separator:a0eb8a11095a9d84b4e1b4af279050127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02068a2cdb99b52d5e02fb665240d277"><td class="memTemplParams" colspan="2"><a class="anchor" id="a02068a2cdb99b52d5e02fb665240d277"></a>
template&lt;typename _Ty &gt; </td></tr>
<tr class="memitem:a02068a2cdb99b52d5e02fb665240d277"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; _Ty &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>task_from_result</b> (_Ty _Param, const <a class="el" href="classpplx_1_1task__options.html">task_options</a> &amp;_TaskOptions=<a class="el" href="classpplx_1_1task__options.html">task_options</a>())</td></tr>
<tr class="separator:a02068a2cdb99b52d5e02fb665240d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5566680a869fffcd36c83742b7f47663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5566680a869fffcd36c83742b7f47663"></a>
<a class="el" href="classpplx_1_1task.html">task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>task_from_result</b> (const <a class="el" href="classpplx_1_1task__options.html">task_options</a> &amp;_TaskOptions=<a class="el" href="classpplx_1_1task__options.html">task_options</a>())</td></tr>
<tr class="separator:a5566680a869fffcd36c83742b7f47663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9fd6c07afdae00293fcff1888ff78d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab9fd6c07afdae00293fcff1888ff78d"></a>
template&lt;typename _TaskType , typename _ExType &gt; </td></tr>
<tr class="memitem:aab9fd6c07afdae00293fcff1888ff78d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpplx_1_1task.html">task</a>&lt; _TaskType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>task_from_exception</b> (_ExType _Exception, const <a class="el" href="classpplx_1_1task__options.html">task_options</a> &amp;_TaskOptions=<a class="el" href="classpplx_1_1task__options.html">task_options</a>())</td></tr>
<tr class="separator:aab9fd6c07afdae00293fcff1888ff78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <code>pplx</code> namespace provides classes and functions that give you access to the Concurrency Runtime, a concurrent programming framework for C++. For more information, see Concurrency Runtime. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a8f3f734bd9b91ceed71bacf4ae1fee6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef details::windows_scheduler <a class="el" href="namespacepplx.html#a8f3f734bd9b91ceed71bacf4ae1fee6a">pplx::default_scheduler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default scheduler type </p>

</div>
</div>
<a class="anchor" id="a44290e93feb32970ccf02e7bdb5672b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacepplx.html#a7569c24382f33970242029beed764a6e">task_group_status</a> <a class="el" href="namespacepplx.html#a7569c24382f33970242029beed764a6e">pplx::task_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type that represents the terminal state of a task. Valid values are <code>completed</code> and <code>canceled</code>. </p>
<dl class="section see"><dt>See also</dt><dd>task Class</dd></dl>

</div>
</div>
<a class="anchor" id="ac172757ccc22c3e784c086cc3792863c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(_pplx_cdecl * pplx::TaskProc_t)(void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An elementary abstraction for a task, defined as <code>void (__cdecl * TaskProc_t)(void *)</code>. A <code>TaskProc</code> is called to invoke the body of a task. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a7569c24382f33970242029beed764a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepplx.html#a7569c24382f33970242029beed764a6e">pplx::task_group_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes the execution status of a <code>task_group</code> or <code>structured_task_group</code> object. A value of this type is returned by numerous methods that wait on tasks scheduled to a task group to complete. </p>
<dl class="section see"><dt>See also</dt><dd>task_group Class, task_group::wait Method, task_group::run_and_wait Method, structured_task_group Class, structured_task_group::wait Method, structured_task_group::run_and_wait Method</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7569c24382f33970242029beed764a6ea716faa59dcf6afa0531293efd19eba46"></a>not_complete&#160;</td><td class="fielddoc">
<p>The tasks queued to the <code>task_group</code> object have not completed. Note that this value is not presently returned by the Concurrency Runtime. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7569c24382f33970242029beed764a6ea87039ec3b562b36fda8b3182cc8c833d"></a>completed&#160;</td><td class="fielddoc">
<p>The tasks queued to the <code>task_group</code> or <code>structured_task_group</code> object completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7569c24382f33970242029beed764a6eab75a9c53022cfdf92b382692f6576462"></a>canceled&#160;</td><td class="fielddoc">
<p>The <code>task_group</code> or <code>structured_task_group</code> object was canceled. One or more tasks may not have executed. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac09b7c5b825a72cdf4f6b59e73e6ba3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_PPLXIMP std::shared_ptr&lt;pplx::scheduler_interface&gt; _pplx_cdecl pplx::get_ambient_scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the ambient scheduler to be used by the PPL constructs </p>

</div>
</div>
<a class="anchor" id="aa2429fe4b49957feae53b2dee7077455"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool _pplx_cdecl pplx::is_task_cancellation_requested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an indication of whether the task that is currently executing has received a request to cancel its execution. Cancellation is requested on a task if the task was created with a cancellation token, and the token source associated with that token is canceled. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the currently executing task has received a request for cancellation, <code>false</code> otherwise. </dd></dl>
<p>If you call this method in the body of a task and it returns <code>true</code>, you must respond with a call to <a class="el" href="">cancel_current_task</a> to acknowledge the cancellation request, after performing any cleanup you need. This will abort the execution of the task and cause it to enter into the <code>canceled</code> state. If you do not respond and continue execution, or return instead of calling <code>cancel_current_task</code>, the task will enter the <code>completed</code> state when it is done. state. </p>
<p>A task is not cancellable if it was created without a cancellation token.</p>
<dl class="section see"><dt>See also</dt><dd>task Class, cancellation_token_source Class, cancellation_token Class, cancel_current_task Function</dd></dl>

</div>
</div>
<a class="anchor" id="a1c24f824352abd1b423a019bfbef9eb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">task</a>&lt;std::vector&lt;_ReturnType&gt; &gt; pplx::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const task&lt; _ReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task&lt; _ReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_ReturnType</td><td>The type of the returned task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Lhs</td><td>The first task to combine into the resulting task. </td></tr>
    <tr><td class="paramname">_Rhs</td><td>The second task to combine into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A task that completes successfully when both of the input tasks have completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </p>
<p class="enddd">To allow for a construct of the sort taskA &amp;&amp; taskB &amp;&amp; taskC, which are combined in pairs, the &amp;&amp; operator produces a <code>task&lt;std::vector&lt;T&gt;&gt;</code> if either one or both of the tasks are of type <code>task&lt;std::vector&lt;T&gt;&gt;</code>.</p>
</dd></dl>
<p>If one of the tasks is canceled or throws an exception, the returned task will complete early, in the canceled state, and the exception, if one is encoutered, will be thrown if you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="a429e1963234b9b28f1747c8c997e10f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">task</a>&lt;std::vector&lt;_ReturnType&gt; &gt; pplx::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const task&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task&lt; _ReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_ReturnType</td><td>The type of the returned task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Lhs</td><td>The first task to combine into the resulting task. </td></tr>
    <tr><td class="paramname">_Rhs</td><td>The second task to combine into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A task that completes successfully when both of the input tasks have completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </p>
<p class="enddd">To allow for a construct of the sort taskA &amp;&amp; taskB &amp;&amp; taskC, which are combined in pairs, the &amp;&amp; operator produces a <code>task&lt;std::vector&lt;T&gt;&gt;</code> if either one or both of the tasks are of type <code>task&lt;std::vector&lt;T&gt;&gt;</code>.</p>
</dd></dl>
<p>If one of the tasks is canceled or throws an exception, the returned task will complete early, in the canceled state, and the exception, if one is encoutered, will be thrown if you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="a2c6d84b73341f2de8a9d13b4e1fe3c11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">task</a>&lt;std::vector&lt;_ReturnType&gt; &gt; pplx::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const task&lt; _ReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_ReturnType</td><td>The type of the returned task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Lhs</td><td>The first task to combine into the resulting task. </td></tr>
    <tr><td class="paramname">_Rhs</td><td>The second task to combine into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A task that completes successfully when both of the input tasks have completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </p>
<p class="enddd">To allow for a construct of the sort taskA &amp;&amp; taskB &amp;&amp; taskC, which are combined in pairs, the &amp;&amp; operator produces a <code>task&lt;std::vector&lt;T&gt;&gt;</code> if either one or both of the tasks are of type <code>task&lt;std::vector&lt;T&gt;&gt;</code>.</p>
</dd></dl>
<p>If one of the tasks is canceled or throws an exception, the returned task will complete early, in the canceled state, and the exception, if one is encoutered, will be thrown if you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="ae533af5e9740e765bdac4971edff9642"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">task</a>&lt;std::vector&lt;_ReturnType&gt; &gt; pplx::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const task&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_ReturnType</td><td>The type of the returned task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Lhs</td><td>The first task to combine into the resulting task. </td></tr>
    <tr><td class="paramname">_Rhs</td><td>The second task to combine into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A task that completes successfully when both of the input tasks have completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </p>
<p class="enddd">To allow for a construct of the sort taskA &amp;&amp; taskB &amp;&amp; taskC, which are combined in pairs, the &amp;&amp; operator produces a <code>task&lt;std::vector&lt;T&gt;&gt;</code> if either one or both of the tasks are of type <code>task&lt;std::vector&lt;T&gt;&gt;</code>.</p>
</dd></dl>
<p>If one of the tasks is canceled or throws an exception, the returned task will complete early, in the canceled state, and the exception, if one is encoutered, will be thrown if you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="a3c0e1abb32fe51d8cf4af446a32c069d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">task</a>&lt;void&gt; pplx::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const task&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a task that will complete succesfully when both of the tasks supplied as arguments complete successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_ReturnType</td><td>The type of the returned task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Lhs</td><td>The first task to combine into the resulting task. </td></tr>
    <tr><td class="paramname">_Rhs</td><td>The second task to combine into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A task that completes successfully when both of the input tasks have completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </p>
<p class="enddd">To allow for a construct of the sort taskA &amp;&amp; taskB &amp;&amp; taskC, which are combined in pairs, the &amp;&amp; operator produces a <code>task&lt;std::vector&lt;T&gt;&gt;</code> if either one or both of the tasks are of type <code>task&lt;std::vector&lt;T&gt;&gt;</code>.</p>
</dd></dl>
<p>If one of the tasks is canceled or throws an exception, the returned task will complete early, in the canceled state, and the exception, if one is encoutered, will be thrown if you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="a818b80cadb056b8b12094997af6ba88d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">task</a>&lt;_ReturnType&gt; pplx::operator|| </td>
          <td>(</td>
          <td class="paramtype">const task&lt; _ReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task&lt; _ReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete successfully when either of the tasks supplied as arguments completes successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_ReturnType</td><td>The type of the returned task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Lhs</td><td>The first task to combine into the resulting task. </td></tr>
    <tr><td class="paramname">_Rhs</td><td>The second task to combine into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A task that completes sucessfully when either of the input tasks has completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </p>
<p class="enddd">To allow for a construct of the sort taskA || taskB &amp;&amp; taskC, which are combined in pairs, with &amp;&amp; taking precedence over ||, the operator|| produces a <code>task&lt;std::vector&lt;T&gt;&gt;</code> if one of the tasks is of type <code>task&lt;std::vector&lt;T&gt;&gt;</code> and the other one is of type <code>task&lt;T&gt;.</code></p>
</dd></dl>
<p>If both of the tasks are canceled or throw exceptions, the returned task will complete in the canceled state, and one of the exceptions, if any are encountered, will be thrown when you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="aaa4e16c30c13c3d9663e1ca4be0a072c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">task</a>&lt;std::vector&lt;_ReturnType&gt; &gt; pplx::operator|| </td>
          <td>(</td>
          <td class="paramtype">const task&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task&lt; _ReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_ReturnType</td><td>The type of the returned task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Lhs</td><td>The first task to combine into the resulting task. </td></tr>
    <tr><td class="paramname">_Rhs</td><td>The second task to combine into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A task that completes sucessfully when either of the input tasks has completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </p>
<p class="enddd">To allow for a construct of the sort taskA || taskB &amp;&amp; taskC, which are combined in pairs, with &amp;&amp; taking precedence over ||, the operator|| produces a <code>task&lt;std::vector&lt;T&gt;&gt;</code> if one of the tasks is of type <code>task&lt;std::vector&lt;T&gt;&gt;</code> and the other one is of type <code>task&lt;T&gt;.</code></p>
</dd></dl>
<p>If both of the tasks are canceled or throw exceptions, the returned task will complete in the canceled state, and one of the exceptions, if any are encountered, will be thrown when you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="ae1dac155b3fc42aeee13defc82d97fe9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">task</a>&lt;std::vector&lt;_ReturnType&gt; &gt; pplx::operator|| </td>
          <td>(</td>
          <td class="paramtype">const task&lt; _ReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task&lt; std::vector&lt; _ReturnType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_ReturnType</td><td>The type of the returned task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Lhs</td><td>The first task to combine into the resulting task. </td></tr>
    <tr><td class="paramname">_Rhs</td><td>The second task to combine into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A task that completes sucessfully when either of the input tasks has completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </p>
<p class="enddd">To allow for a construct of the sort taskA || taskB &amp;&amp; taskC, which are combined in pairs, with &amp;&amp; taking precedence over ||, the operator|| produces a <code>task&lt;std::vector&lt;T&gt;&gt;</code> if one of the tasks is of type <code>task&lt;std::vector&lt;T&gt;&gt;</code> and the other one is of type <code>task&lt;T&gt;.</code></p>
</dd></dl>
<p>If both of the tasks are canceled or throw exceptions, the returned task will complete in the canceled state, and one of the exceptions, if any are encountered, will be thrown when you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="a0eb8a11095a9d84b4e1b4af279050127"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpplx_1_1task.html">task</a>&lt;void&gt; pplx::operator|| </td>
          <td>(</td>
          <td class="paramtype">const task&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>_Rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_ReturnType</td><td>The type of the returned task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Lhs</td><td>The first task to combine into the resulting task. </td></tr>
    <tr><td class="paramname">_Rhs</td><td>The second task to combine into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">A task that completes sucessfully when either of the input tasks has completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </p>
<p class="enddd">To allow for a construct of the sort taskA || taskB &amp;&amp; taskC, which are combined in pairs, with &amp;&amp; taking precedence over ||, the operator|| produces a <code>task&lt;std::vector&lt;T&gt;&gt;</code> if one of the tasks is of type <code>task&lt;std::vector&lt;T&gt;&gt;</code> and the other one is of type <code>task&lt;T&gt;.</code></p>
</dd></dl>
<p>If both of the tasks are canceled or throw exceptions, the returned task will complete in the canceled state, and one of the exceptions, if any are encountered, will be thrown when you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="ac98993a43756c17916a9a14d89f1ca05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_PPLXIMP void _pplx_cdecl pplx::set_ambient_scheduler </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; pplx::scheduler_interface &gt;&#160;</td>
          <td class="paramname"><em>_Scheduler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ambient scheduler to be used by the PPL constructs. </p>

</div>
</div>
<a class="anchor" id="ae4dcfa2f691ee1f2176157a485bfca01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pplx::when_all </td>
          <td>(</td>
          <td class="paramtype">_Iterator&#160;</td>
          <td class="paramname"><em>_Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Iterator&#160;</td>
          <td class="paramname"><em>_End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task_options &amp;&#160;</td>
          <td class="paramname"><em>_TaskOptions</em> = <code>task_options()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype (details::_WhenAllImpl&lt;typename std::iterator_traits&lt;_Iterator&gt;::value_type::result_type, _Iterator&gt;::_Perform(_TaskOptions, _Begin, _End))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete successfully when all of the tasks supplied as arguments complete successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Iterator</td><td>The type of the input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Begin</td><td>The position of the first element in the range of elements to be combined into the resulting task. </td></tr>
    <tr><td class="paramname">_End</td><td>The position of the first element beyond the range of elements to be combined into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A task that completes sucessfully when all of the input tasks have completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::vector&lt;T&gt;&gt;</code>. If the input tasks are of type <code>void</code> the output task will also be a <code>task&lt;void&gt;</code>. </dd></dl>
<p>If one of the tasks is canceled or throws an exception, the returned task will complete early, in the canceled state, and the exception, if one is encoutered, will be thrown if you call <code>get()</code> or <code>wait()</code> on that task. </p>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="ab497ff57fed159d56367d8098dd3324a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pplx::when_any </td>
          <td>(</td>
          <td class="paramtype">_Iterator&#160;</td>
          <td class="paramname"><em>_Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Iterator&#160;</td>
          <td class="paramname"><em>_End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const task_options &amp;&#160;</td>
          <td class="paramname"><em>_TaskOptions</em> = <code>task_options()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype (details::_WhenAnyImpl&lt;typename std::iterator_traits&lt;_Iterator&gt;::value_type::result_type, _Iterator&gt;::_Perform(_TaskOptions, _Begin, _End))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Iterator</td><td>The type of the input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Begin</td><td>The position of the first element in the range of elements to be combined into the resulting task. </td></tr>
    <tr><td class="paramname">_End</td><td>The position of the first element beyond the range of elements to be combined into the resulting task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A task that completes successfully when any one of the input tasks has completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::pair&lt;T, size_t&gt;&gt;&gt;</code>, where the first element of the pair is the result of the completing task, and the second element is the index of the task that finished. If the input tasks are of type <code>void</code> the output is a <code>task&lt;size_t&gt;</code>, where the result is the index of the completing task. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
<a class="anchor" id="a009f35ac6af0b829b593f9d705a5ca09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pplx::when_any </td>
          <td>(</td>
          <td class="paramtype">_Iterator&#160;</td>
          <td class="paramname"><em>_Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Iterator&#160;</td>
          <td class="paramname"><em>_End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cancellation_token&#160;</td>
          <td class="paramname"><em>_CancellationToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype (details::_WhenAnyImpl&lt;typename std::iterator_traits&lt;_Iterator&gt;::value_type::result_type, _Iterator&gt;::_Perform(_CancellationToken._GetImplValue(), _Begin, _End))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a task that will complete successfully when any of the tasks supplied as arguments completes successfully. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Iterator</td><td>The type of the input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_Begin</td><td>The position of the first element in the range of elements to be combined into the resulting task. </td></tr>
    <tr><td class="paramname">_End</td><td>The position of the first element beyond the range of elements to be combined into the resulting task. </td></tr>
    <tr><td class="paramname">_CancellationToken</td><td>The cancellation token which controls cancellation of the returned task. If you do not provide a cancellation token, the resulting task will receive the cancellation token of the task that causes it to complete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A task that completes successfully when any one of the input tasks has completed successfully. If the input tasks are of type <code>T</code>, the output of this function will be a <code>task&lt;std::pair&lt;T, size_t&gt;&gt;&gt;</code>, where the first element of the pair is the result of the completing task, and the second element is the index of the task that finished. If the input tasks are of type <code>void</code> the output is a <code>task&lt;size_t&gt;</code>, where the result is the index of the completing task. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Task Parallelism (Concurrency Runtime)</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 18 2015 15:46:08 for C++ Rest SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
