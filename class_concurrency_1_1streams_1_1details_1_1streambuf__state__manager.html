<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>C++ Rest SDK: Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cloud.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Rest SDK
   </div>
   <div id="projectbrief">The C++ REST SDK is a Microsoft project for cloud-based client-server communication in native code using a modern asynchronous C++ API design. This project aims to help C++ developers connect to and interact with services.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Concurrency</b></li><li class="navelem"><a class="el" href="namespace_concurrency_1_1streams.html">streams</a></li><li class="navelem"><b>details</b></li><li class="navelem"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">streambuf_state_manager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.png" usemap="#Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;_map" alt=""/>
  <map id="Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;_map" name="Concurrency::streams::details::streambuf_state_manager&lt; _CharType &gt;_map">
<area href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html" title="Stream buffer base class. " alt="Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;" shape="rect" coords="473,0,936,24"/>
<area href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html" title="Private stream buffer implementation for file streams. The class itself should not be used in applica..." alt="Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;" shape="rect" coords="0,112,463,136"/>
<area href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html" title="The basic_producer_consumer_buffer class serves as a memory-based steam buffer that supports both wri..." alt="Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;" shape="rect" coords="473,112,936,136"/>
<area href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html" title="The basic_rawptr_buffer class serves as a memory-based steam buffer that supports both writing and re..." alt="Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;" shape="rect" coords="946,112,1409,136"/>
<area href="class_concurrency_1_1streams_1_1details_1_1basic__stdio__buffer.html" title="The basic_stdio_buffer class serves to support interoperability with STL stream buffers. Sitting atop a std::streambuf, which does all the I/O, instances of this class may read and write data to standard iostreams. The class itself should not be used in application code, it is used by the stream definitions farther down in the header file. " alt="Concurrency::streams::details::basic_stdio_buffer&lt; _CharType &gt;" shape="rect" coords="1419,112,1882,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afd16abf255509d80388b99f9d9625343"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd16abf255509d80388b99f9d9625343"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">details::basic_streambuf</a>&lt; _CharType &gt;::traits&#160;</td><td class="memItemRight" valign="bottom"><b>traits</b></td></tr>
<tr class="separator:afd16abf255509d80388b99f9d9625343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514a823a5b04ed3710087a7ed60ac9e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a514a823a5b04ed3710087a7ed60ac9e6"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">details::basic_streambuf</a>&lt; _CharType &gt;::int_type&#160;</td><td class="memItemRight" valign="bottom"><b>int_type</b></td></tr>
<tr class="separator:a514a823a5b04ed3710087a7ed60ac9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f724e70ef1c92e0e22452a65001b2fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f724e70ef1c92e0e22452a65001b2fb"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">details::basic_streambuf</a>&lt; _CharType &gt;::pos_type&#160;</td><td class="memItemRight" valign="bottom"><b>pos_type</b></td></tr>
<tr class="separator:a9f724e70ef1c92e0e22452a65001b2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb7d6a6fee0bc2a0e9ee1eb5bc8e6d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cb7d6a6fee0bc2a0e9ee1eb5bc8e6d5"></a>
typedef <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">details::basic_streambuf</a>&lt; _CharType &gt;::off_type&#160;</td><td class="memItemRight" valign="bottom"><b>off_type</b></td></tr>
<tr class="separator:a3cb7d6a6fee0bc2a0e9ee1eb5bc8e6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a></td></tr>
<tr class="memitem:a7cd70561849f966823d4534aa38963ad inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cd70561849f966823d4534aa38963ad"></a>
typedef _CharType&#160;</td><td class="memItemRight" valign="bottom"><b>char_type</b></td></tr>
<tr class="separator:a7cd70561849f966823d4534aa38963ad inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc879afd2840d1df21fe86248910052 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dc879afd2840d1df21fe86248910052"></a>
typedef ::concurrency::streams::char_traits&lt; _CharType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>traits</b></td></tr>
<tr class="separator:a7dc879afd2840d1df21fe86248910052 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ff619438b3e71e6f601bb518a67a9 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a079ff619438b3e71e6f601bb518a67a9"></a>
typedef traits::int_type&#160;</td><td class="memItemRight" valign="bottom"><b>int_type</b></td></tr>
<tr class="separator:a079ff619438b3e71e6f601bb518a67a9 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139102a6d042dc709717b97d2565fcf3 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a139102a6d042dc709717b97d2565fcf3"></a>
typedef traits::pos_type&#160;</td><td class="memItemRight" valign="bottom"><b>pos_type</b></td></tr>
<tr class="separator:a139102a6d042dc709717b97d2565fcf3 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e021e969ca85d498840d5adee6f02e3 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e021e969ca85d498840d5adee6f02e3"></a>
typedef traits::off_type&#160;</td><td class="memItemRight" valign="bottom"><b>off_type</b></td></tr>
<tr class="separator:a9e021e969ca85d498840d5adee6f02e3 inherit pub_types_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aed2334bda427e1aab975a6ddc9179187"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aed2334bda427e1aab975a6ddc9179187">can_read</a> () const </td></tr>
<tr class="memdesc:aed2334bda427e1aab975a6ddc9179187"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>can_read</code> is used to determine whether a stream buffer will support read operations (get).  <a href="#aed2334bda427e1aab975a6ddc9179187">More...</a><br /></td></tr>
<tr class="separator:aed2334bda427e1aab975a6ddc9179187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548ca961ef6062e52094679745b5a3c2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a548ca961ef6062e52094679745b5a3c2">can_write</a> () const </td></tr>
<tr class="memdesc:a548ca961ef6062e52094679745b5a3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>can_write</code> is used to determine whether a stream buffer will support write operations (put).  <a href="#a548ca961ef6062e52094679745b5a3c2">More...</a><br /></td></tr>
<tr class="separator:a548ca961ef6062e52094679745b5a3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae803b65c032ea6e9dcd54b92e0c9d512"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ae803b65c032ea6e9dcd54b92e0c9d512">is_open</a> () const </td></tr>
<tr class="memdesc:ae803b65c032ea6e9dcd54b92e0c9d512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream buffer is open.  <a href="#ae803b65c032ea6e9dcd54b92e0c9d512">More...</a><br /></td></tr>
<tr class="separator:ae803b65c032ea6e9dcd54b92e0c9d512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e2852cda70d6424ef8787ebbd3c25f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#af7e2852cda70d6424ef8787ebbd3c25f">close</a> (std::ios_base::openmode mode=std::ios_base::in|std::ios_base::out)</td></tr>
<tr class="memdesc:af7e2852cda70d6424ef8787ebbd3c25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream buffer, preventing further read or write operations.  <a href="#af7e2852cda70d6424ef8787ebbd3c25f">More...</a><br /></td></tr>
<tr class="separator:af7e2852cda70d6424ef8787ebbd3c25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749a8c69f0c9870ab534ebe2b1e0914c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a749a8c69f0c9870ab534ebe2b1e0914c">close</a> (std::ios_base::openmode mode, std::exception_ptr eptr)</td></tr>
<tr class="memdesc:a749a8c69f0c9870ab534ebe2b1e0914c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the stream buffer with an exception.  <a href="#a749a8c69f0c9870ab534ebe2b1e0914c">More...</a><br /></td></tr>
<tr class="separator:a749a8c69f0c9870ab534ebe2b1e0914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ec23de40fe0390b6eeed04ac352de1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a70ec23de40fe0390b6eeed04ac352de1">is_eof</a> () const </td></tr>
<tr class="memdesc:a70ec23de40fe0390b6eeed04ac352de1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>is_eof</code> is used to determine whether a read head has reached the end of the buffer.  <a href="#a70ec23de40fe0390b6eeed04ac352de1">More...</a><br /></td></tr>
<tr class="separator:a70ec23de40fe0390b6eeed04ac352de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380b990b895a20224ca45d6c7c11190c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a380b990b895a20224ca45d6c7c11190c">putc</a> (_CharType ch)</td></tr>
<tr class="memdesc:a380b990b895a20224ca45d6c7c11190c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single character to the stream.  <a href="#a380b990b895a20224ca45d6c7c11190c">More...</a><br /></td></tr>
<tr class="separator:a380b990b895a20224ca45d6c7c11190c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4927b4f17f050f1fd10ed599cb49b836"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a4927b4f17f050f1fd10ed599cb49b836">putn</a> (const _CharType *ptr, size_t count)</td></tr>
<tr class="memdesc:a4927b4f17f050f1fd10ed599cb49b836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a number of characters to the stream.  <a href="#a4927b4f17f050f1fd10ed599cb49b836">More...</a><br /></td></tr>
<tr class="separator:a4927b4f17f050f1fd10ed599cb49b836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48557a7d9d216500f879abc912b5f24f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a48557a7d9d216500f879abc912b5f24f">putn_nocopy</a> (const _CharType *ptr, size_t count)</td></tr>
<tr class="memdesc:a48557a7d9d216500f879abc912b5f24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a number of characters to the stream. Note: callers must make sure the data to be written is valid until the returned task completes.  <a href="#a48557a7d9d216500f879abc912b5f24f">More...</a><br /></td></tr>
<tr class="separator:a48557a7d9d216500f879abc912b5f24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9f0ad2b5ddf49b316751aa18a9cf58"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2e9f0ad2b5ddf49b316751aa18a9cf58">bumpc</a> ()</td></tr>
<tr class="memdesc:a2e9f0ad2b5ddf49b316751aa18a9cf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream and advances the read position.  <a href="#a2e9f0ad2b5ddf49b316751aa18a9cf58">More...</a><br /></td></tr>
<tr class="separator:a2e9f0ad2b5ddf49b316751aa18a9cf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f5fd8cab84a41d75e8476015e83331"><td class="memItemLeft" align="right" valign="top">virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa3f5fd8cab84a41d75e8476015e83331">sbumpc</a> ()</td></tr>
<tr class="memdesc:aa3f5fd8cab84a41d75e8476015e83331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream and advances the read position.  <a href="#aa3f5fd8cab84a41d75e8476015e83331">More...</a><br /></td></tr>
<tr class="separator:aa3f5fd8cab84a41d75e8476015e83331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c5d6cdc4f5dfcdd2859b4fa3872c95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa6c5d6cdc4f5dfcdd2859b4fa3872c95">getc</a> ()</td></tr>
<tr class="memdesc:aa6c5d6cdc4f5dfcdd2859b4fa3872c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream without advancing the read position.  <a href="#aa6c5d6cdc4f5dfcdd2859b4fa3872c95">More...</a><br /></td></tr>
<tr class="separator:aa6c5d6cdc4f5dfcdd2859b4fa3872c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9df9f0e827354a4f3d673e6d2643f52"><td class="memItemLeft" align="right" valign="top">virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ac9df9f0e827354a4f3d673e6d2643f52">sgetc</a> ()</td></tr>
<tr class="memdesc:ac9df9f0e827354a4f3d673e6d2643f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a single character from the stream without advancing the read position.  <a href="#ac9df9f0e827354a4f3d673e6d2643f52">More...</a><br /></td></tr>
<tr class="separator:ac9df9f0e827354a4f3d673e6d2643f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee850cc04e3ca57084ab11523e1db2e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#acee850cc04e3ca57084ab11523e1db2e">nextc</a> ()</td></tr>
<tr class="memdesc:acee850cc04e3ca57084ab11523e1db2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the read position, then returns the next character without advancing again.  <a href="#acee850cc04e3ca57084ab11523e1db2e">More...</a><br /></td></tr>
<tr class="separator:acee850cc04e3ca57084ab11523e1db2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2c264214da39baadca7755be4a9e0e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a5c2c264214da39baadca7755be4a9e0e">ungetc</a> ()</td></tr>
<tr class="memdesc:a5c2c264214da39baadca7755be4a9e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retreats the read position, then returns the current character without advancing.  <a href="#a5c2c264214da39baadca7755be4a9e0e">More...</a><br /></td></tr>
<tr class="separator:a5c2c264214da39baadca7755be4a9e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e03bfa260c8b9a2678e86c1c980c3a5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2e03bfa260c8b9a2678e86c1c980c3a5">getn</a> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)</td></tr>
<tr class="memdesc:a2e03bfa260c8b9a2678e86c1c980c3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads up to a given number of characters from the stream.  <a href="#a2e03bfa260c8b9a2678e86c1c980c3a5">More...</a><br /></td></tr>
<tr class="separator:a2e03bfa260c8b9a2678e86c1c980c3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac759d4d90e6b33da98ed8f495c138dd8"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ac759d4d90e6b33da98ed8f495c138dd8">scopy</a> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)</td></tr>
<tr class="memdesc:ac759d4d90e6b33da98ed8f495c138dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies up to a given number of characters from the stream, synchronously.  <a href="#ac759d4d90e6b33da98ed8f495c138dd8">More...</a><br /></td></tr>
<tr class="separator:ac759d4d90e6b33da98ed8f495c138dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747f7e31451884a9448be43d11680285"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a747f7e31451884a9448be43d11680285">sync</a> ()</td></tr>
<tr class="memdesc:a747f7e31451884a9448be43d11680285"><td class="mdescLeft">&#160;</td><td class="mdescRight">For output streams, flush any internally buffered data to the underlying medium.  <a href="#a747f7e31451884a9448be43d11680285">More...</a><br /></td></tr>
<tr class="separator:a747f7e31451884a9448be43d11680285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd1d77a11059cc5f7f379b54bf56e53"><td class="memItemLeft" align="right" valign="top">virtual std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2fd1d77a11059cc5f7f379b54bf56e53">exception</a> () const </td></tr>
<tr class="memdesc:a2fd1d77a11059cc5f7f379b54bf56e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stream buffer exception_ptr if it has been set.  <a href="#a2fd1d77a11059cc5f7f379b54bf56e53">More...</a><br /></td></tr>
<tr class="separator:a2fd1d77a11059cc5f7f379b54bf56e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7637174c543cfe0a900a40e1a7c8df15"><td class="memItemLeft" align="right" valign="top">_CharType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a7637174c543cfe0a900a40e1a7c8df15">alloc</a> (size_t count)</td></tr>
<tr class="memdesc:a7637174c543cfe0a900a40e1a7c8df15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a contiguous memory block and returns it.  <a href="#a7637174c543cfe0a900a40e1a7c8df15">More...</a><br /></td></tr>
<tr class="separator:a7637174c543cfe0a900a40e1a7c8df15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e07f5f2e05a4e176353b901acc326d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#af0e07f5f2e05a4e176353b901acc326d">commit</a> (size_t count)</td></tr>
<tr class="memdesc:af0e07f5f2e05a4e176353b901acc326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a block already allocated by the stream buffer.  <a href="#af0e07f5f2e05a4e176353b901acc326d">More...</a><br /></td></tr>
<tr class="separator:af0e07f5f2e05a4e176353b901acc326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fc42530539a84f98b1d1f48cb2fcd0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a76fc42530539a84f98b1d1f48cb2fcd0">can_seek</a> () const  =0</td></tr>
<tr class="memdesc:a76fc42530539a84f98b1d1f48cb2fcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>can_seek<code> is used to determine whether a stream buffer supports seeking. </code></code><code><code> </code></code> <a href="#a76fc42530539a84f98b1d1f48cb2fcd0">More...</a><br /></td></tr>
<tr class="separator:a76fc42530539a84f98b1d1f48cb2fcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e719975f42244d923c72e2e322faa07"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a1e719975f42244d923c72e2e322faa07">has_size</a> () const  =0</td></tr>
<tr class="memdesc:a1e719975f42244d923c72e2e322faa07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>has_size<code> is used to determine whether a stream buffer supports <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a6d2e4ca19b7eda6cd5348768d9c3f548" title="Gets the size of the stream, if known. Calls to has_size will determine whether the result of size ca...">size()</a>. </code></code><code><code> </code></code> <a href="#a1e719975f42244d923c72e2e322faa07">More...</a><br /></td></tr>
<tr class="separator:a1e719975f42244d923c72e2e322faa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2e4ca19b7eda6cd5348768d9c3f548"><td class="memItemLeft" align="right" valign="top">virtual utility::size64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a6d2e4ca19b7eda6cd5348768d9c3f548">size</a> () const </td></tr>
<tr class="memdesc:a6d2e4ca19b7eda6cd5348768d9c3f548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the stream, if known. Calls to <code>has_size</code> will determine whether the result of <code>size</code> can be relied on.  <a href="#a6d2e4ca19b7eda6cd5348768d9c3f548">More...</a><br /></td></tr>
<tr class="separator:a6d2e4ca19b7eda6cd5348768d9c3f548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909ec3a6fc564cb06937aff9cea896b0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a909ec3a6fc564cb06937aff9cea896b0">buffer_size</a> (std::ios_base::openmode direction=std::ios_base::in) const  =0</td></tr>
<tr class="memdesc:a909ec3a6fc564cb06937aff9cea896b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stream buffer size, if one has been set.  <a href="#a909ec3a6fc564cb06937aff9cea896b0">More...</a><br /></td></tr>
<tr class="separator:a909ec3a6fc564cb06937aff9cea896b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302f500fe45a006d6e264d320f87b3e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a302f500fe45a006d6e264d320f87b3e9">set_buffer_size</a> (size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a6d2e4ca19b7eda6cd5348768d9c3f548">size</a>, std::ios_base::openmode direction=std::ios_base::in)=0</td></tr>
<tr class="memdesc:a302f500fe45a006d6e264d320f87b3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stream buffer implementation to buffer or not buffer.  <a href="#a302f500fe45a006d6e264d320f87b3e9">More...</a><br /></td></tr>
<tr class="separator:a302f500fe45a006d6e264d320f87b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e02ea1d54f3b1203787616bf8340430"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a1e02ea1d54f3b1203787616bf8340430">in_avail</a> () const  =0</td></tr>
<tr class="memdesc:a1e02ea1d54f3b1203787616bf8340430"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any input stream, <code>in_avail</code> returns the number of characters that are immediately available to be consumed without blocking. May be used in conjunction with &lt;cref="::sbumpc method"/&gt; to read data without incurring the overhead of using tasks.  <a href="#a1e02ea1d54f3b1203787616bf8340430">More...</a><br /></td></tr>
<tr class="separator:a1e02ea1d54f3b1203787616bf8340430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acd807ca4d033cef91de1acd4f41fc3"><td class="memItemLeft" align="right" valign="top">virtual pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a4acd807ca4d033cef91de1acd4f41fc3">getpos</a> (std::ios_base::openmode direction) const  =0</td></tr>
<tr class="memdesc:a4acd807ca4d033cef91de1acd4f41fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current read or write position in the stream.  <a href="#a4acd807ca4d033cef91de1acd4f41fc3">More...</a><br /></td></tr>
<tr class="separator:a4acd807ca4d033cef91de1acd4f41fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771c9acc022390635bad4453f59a44dc"><td class="memItemLeft" align="right" valign="top">virtual pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a771c9acc022390635bad4453f59a44dc">seekpos</a> (pos_type pos, std::ios_base::openmode direction)=0</td></tr>
<tr class="memdesc:a771c9acc022390635bad4453f59a44dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeks to the given position.  <a href="#a771c9acc022390635bad4453f59a44dc">More...</a><br /></td></tr>
<tr class="separator:a771c9acc022390635bad4453f59a44dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7a83da4fc15bda3e02dbc91d21bc2a"><td class="memItemLeft" align="right" valign="top">virtual pos_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a2d7a83da4fc15bda3e02dbc91d21bc2a">seekoff</a> (off_type offset, std::ios_base::seekdir way, std::ios_base::openmode mode)=0</td></tr>
<tr class="memdesc:a2d7a83da4fc15bda3e02dbc91d21bc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeks to a position given by a relative offset.  <a href="#a2d7a83da4fc15bda3e02dbc91d21bc2a">More...</a><br /></td></tr>
<tr class="separator:a2d7a83da4fc15bda3e02dbc91d21bc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb84f15b01c2133012b1c1b7e8be8b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacb84f15b01c2133012b1c1b7e8be8b0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>acquire</b> (_Out_writes_(count) _CharType *&amp;ptr, _In_ size_t &amp;count)=0</td></tr>
<tr class="separator:aacb84f15b01c2133012b1c1b7e8be8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68390e9e8286f7911bde2dd91bbbf209"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a68390e9e8286f7911bde2dd91bbbf209">release</a> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)=0</td></tr>
<tr class="memdesc:a68390e9e8286f7911bde2dd91bbbf209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a block of data acquired using ::acquire method. This frees the stream buffer to de-allocate the memory, if it so desires. Move the read position ahead by the count.  <a href="#a68390e9e8286f7911bde2dd91bbbf209">More...</a><br /></td></tr>
<tr class="separator:a68390e9e8286f7911bde2dd91bbbf209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a></td></tr>
<tr class="memitem:ae8d7242e86aa6bfba080a18afcdf610b inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#ae8d7242e86aa6bfba080a18afcdf610b">~basic_streambuf</a> ()</td></tr>
<tr class="memdesc:ae8d7242e86aa6bfba080a18afcdf610b inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor for stream buffers.  <a href="#ae8d7242e86aa6bfba080a18afcdf610b">More...</a><br /></td></tr>
<tr class="separator:ae8d7242e86aa6bfba080a18afcdf610b inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcdb3c58237bcae05dd7a5649fb25e9 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top">virtual _CharType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a5fcdb3c58237bcae05dd7a5649fb25e9">alloc</a> (_In_ size_t count)=0</td></tr>
<tr class="memdesc:a5fcdb3c58237bcae05dd7a5649fb25e9 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a contiguous memory block and returns it.  <a href="#a5fcdb3c58237bcae05dd7a5649fb25e9">More...</a><br /></td></tr>
<tr class="separator:a5fcdb3c58237bcae05dd7a5649fb25e9 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019704086210ed4d54f009cb9105a118 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a019704086210ed4d54f009cb9105a118">commit</a> (_In_ size_t count)=0</td></tr>
<tr class="memdesc:a019704086210ed4d54f009cb9105a118 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a block already allocated by the stream buffer.  <a href="#a019704086210ed4d54f009cb9105a118">More...</a><br /></td></tr>
<tr class="separator:a019704086210ed4d54f009cb9105a118 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc68282f1bfa06b97e09380e3b64405 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#aafc68282f1bfa06b97e09380e3b64405">acquire</a> (_Out_ _CharType *&amp;ptr, _Out_ size_t &amp;count)=0</td></tr>
<tr class="memdesc:aafc68282f1bfa06b97e09380e3b64405 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the next already allocated contiguous block of data.  <a href="#aafc68282f1bfa06b97e09380e3b64405">More...</a><br /></td></tr>
<tr class="separator:aafc68282f1bfa06b97e09380e3b64405 inherit pub_methods_class_concurrency_1_1streams_1_1details_1_1basic__streambuf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad030dd72c3b9658da729de2a095be85e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad030dd72c3b9658da729de2a095be85e"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_putc</b> (_CharType ch)=0</td></tr>
<tr class="separator:ad030dd72c3b9658da729de2a095be85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea2b71412d16332b0abe8fe4dad2e2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea2b71412d16332b0abe8fe4dad2e2d"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_putn</b> (const _CharType *ptr, size_t count, bool)</td></tr>
<tr class="separator:a7ea2b71412d16332b0abe8fe4dad2e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac279b4501892ddf2167b53738bdb569b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac279b4501892ddf2167b53738bdb569b"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_putn</b> (const _CharType *ptr, size_t count)=0</td></tr>
<tr class="separator:ac279b4501892ddf2167b53738bdb569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b5c63fe250fddecc88ea9bc8199f01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5b5c63fe250fddecc88ea9bc8199f01"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_bumpc</b> ()=0</td></tr>
<tr class="separator:ab5b5c63fe250fddecc88ea9bc8199f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6b8767534cc84e8079213dd75ac658"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e6b8767534cc84e8079213dd75ac658"></a>
virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><b>_sbumpc</b> ()=0</td></tr>
<tr class="separator:a6e6b8767534cc84e8079213dd75ac658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215dc3f57b325137531607d6cf08027d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a215dc3f57b325137531607d6cf08027d"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_getc</b> ()=0</td></tr>
<tr class="separator:a215dc3f57b325137531607d6cf08027d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4d3091630b126091a3dfd677e5f56a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd4d3091630b126091a3dfd677e5f56a"></a>
virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><b>_sgetc</b> ()=0</td></tr>
<tr class="separator:afd4d3091630b126091a3dfd677e5f56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44ea457f894f0d2615a48ace3907590"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa44ea457f894f0d2615a48ace3907590"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_nextc</b> ()=0</td></tr>
<tr class="separator:aa44ea457f894f0d2615a48ace3907590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707d4f6ff3028ebfc0077da6eda7cef8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a707d4f6ff3028ebfc0077da6eda7cef8"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; int_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_ungetc</b> ()=0</td></tr>
<tr class="separator:a707d4f6ff3028ebfc0077da6eda7cef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea53dfc81b3138945da0e76fac87f6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abea53dfc81b3138945da0e76fac87f6a"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_getn</b> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)=0</td></tr>
<tr class="separator:abea53dfc81b3138945da0e76fac87f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ce1230fd67ee5ae10533a749793e34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29ce1230fd67ee5ae10533a749793e34"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_scopy</b> (_Out_writes_(count) _CharType *ptr, _In_ size_t count)=0</td></tr>
<tr class="separator:a29ce1230fd67ee5ae10533a749793e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb9020bb3229df90dfa1320170cee28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cb9020bb3229df90dfa1320170cee28"></a>
virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_sync</b> ()=0</td></tr>
<tr class="separator:a1cb9020bb3229df90dfa1320170cee28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95772a17adf42cbef070f843c3aad83c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95772a17adf42cbef070f843c3aad83c"></a>
virtual _CharType *&#160;</td><td class="memItemRight" valign="bottom"><b>_alloc</b> (size_t count)=0</td></tr>
<tr class="separator:a95772a17adf42cbef070f843c3aad83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0b577ec0fb9deac4d42deed72807bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f0b577ec0fb9deac4d42deed72807bd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>_commit</b> (size_t count)=0</td></tr>
<tr class="separator:a2f0b577ec0fb9deac4d42deed72807bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa006a004495768b97e9718ef89a675f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#aa006a004495768b97e9718ef89a675f1">_close_read</a> ()</td></tr>
<tr class="memdesc:aa006a004495768b97e9718ef89a675f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The real read head close operation, implementation should override it if there is any resource to be released.  <a href="#aa006a004495768b97e9718ef89a675f1">More...</a><br /></td></tr>
<tr class="separator:aa006a004495768b97e9718ef89a675f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bd370ba0b9a6e75e29a0d80903db34"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#ad9bd370ba0b9a6e75e29a0d80903db34">_close_write</a> ()</td></tr>
<tr class="memdesc:ad9bd370ba0b9a6e75e29a0d80903db34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The real write head close operation, implementation should override it if there is any resource to be released.  <a href="#ad9bd370ba0b9a6e75e29a0d80903db34">More...</a><br /></td></tr>
<tr class="separator:ad9bd370ba0b9a6e75e29a0d80903db34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025ea08f6676b593619704b56fc0c674"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a025ea08f6676b593619704b56fc0c674"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>streambuf_state_manager</b> (std::ios_base::openmode mode)</td></tr>
<tr class="separator:a025ea08f6676b593619704b56fc0c674"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abbb9ccb5164574d23a5672f5b7dcdf23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbb9ccb5164574d23a5672f5b7dcdf23"></a>
std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>m_currentException</b></td></tr>
<tr class="separator:abbb9ccb5164574d23a5672f5b7dcdf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2936187fac4351285569e86f44b9484"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2936187fac4351285569e86f44b9484"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_stream_can_read</b></td></tr>
<tr class="separator:ad2936187fac4351285569e86f44b9484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d42ecf51cc3a19c97803387d07d2af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02d42ecf51cc3a19c97803387d07d2af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_stream_can_write</b></td></tr>
<tr class="separator:a02d42ecf51cc3a19c97803387d07d2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e7b95c3e1c2c3326ef63af05a50bb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71e7b95c3e1c2c3326ef63af05a50bb2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_stream_read_eof</b></td></tr>
<tr class="separator:a71e7b95c3e1c2c3326ef63af05a50bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca050fcb2116f7e1558674bf7624c172"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca050fcb2116f7e1558674bf7624c172"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_alloced</b></td></tr>
<tr class="separator:aca050fcb2116f7e1558674bf7624c172"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa006a004495768b97e9718ef89a675f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::_close_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The real read head close operation, implementation should override it if there is any resource to be released. </p>

<p>Reimplemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#ac6729b875cf1059f5a81373fdca70d40">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad9bd370ba0b9a6e75e29a0d80903db34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::_close_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The real write head close operation, implementation should override it if there is any resource to be released. </p>

<p>Reimplemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a93dc9e602418315ad46ef30d8496f3a3">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7637174c543cfe0a900a40e1a7c8df15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_CharType* <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a contiguous memory block and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of characters to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a block to write to, null if the stream buffer implementation does not support alloc/commit.</dd></dl>
<p>This is intended as an advanced API to be used only when it is important to avoid extra copies.</p>

</div>
</div>
<a class="anchor" id="a909ec3a6fc564cb06937aff9cea896b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::buffer_size </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>direction</em> = <code>std::ios_base::in</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the stream buffer size, if one has been set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The direction of buffering (in or out)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the internal buffer (for the given direction).</dd></dl>
<p>An implementation that does not support buffering will always return 0.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a950f82dd04da3cd7b3868e778a7abde0">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a165cae38f8a333a875abb0f56831a52b">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#a7ebda374de3b831b89b934cfddd999c4">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#acaa1f184f84d1084c18328e69c4c8791">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a4afbd85aa213c07ce0968c62a651c0de">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2e9f0ad2b5ddf49b316751aa18a9cf58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::bumpc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single character from the stream and advances the read position. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the character. EOF if the read fails.</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a747d5a580f8723719d22b37a1a5ddb74">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aed2334bda427e1aab975a6ddc9179187"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::can_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>can_read</code> is used to determine whether a stream buffer will support read operations (get). </p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a2335e901ca091ed71919c39f2eb93c0c">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a76fc42530539a84f98b1d1f48cb2fcd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::can_seek </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>can_seek<code> is used to determine whether a stream buffer supports seeking. </code></code><code><code> </code></code></p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a80c15f6d53d985aefbaeea93d522baa4">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a103c624ba65828b372599664a6428380">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a8e858e01ca9cc523cf5e93c541fa08f1">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#a3dfa0ffcfb66c7f6ab9fe8ea363bd441">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#af343d4627e24beac6726778d9d69622d">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a548ca961ef6062e52094679745b5a3c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::can_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>can_write</code> is used to determine whether a stream buffer will support write operations (put). </p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a8f6074a528cce6fd4b48961768edfc40">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af7e2852cda70d6424ef8787ebbd3c25f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::close </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>std::ios_base::in&#160;|&#160;std::ios_base::out</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the stream buffer, preventing further read or write operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The I/O mode (in or out) to close for.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#ad4c03d843d8047e666e9dcdc6cc0256f">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#aeb6fccf66e7b5375bcb53ac6f0f56b38">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a749a8c69f0c9870ab534ebe2b1e0914c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::close </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::exception_ptr&#160;</td>
          <td class="paramname"><em>eptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the stream buffer with an exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The I/O mode (in or out) to close for.</td></tr>
    <tr><td class="paramname">eptr</td><td>Pointer to the exception.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a769af62e3efde5914a3c08ee78a6cc13">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af0e07f5f2e05a4e176353b901acc326d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::commit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a block already allocated by the stream buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of characters to be committed.</td></tr>
  </table>
  </dd>
</dl>
<p>This is intended as an advanced API to be used only when it is important to avoid extra copies.</p>

</div>
</div>
<a class="anchor" id="a2fd1d77a11059cc5f7f379b54bf56e53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::exception_ptr <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::exception </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the stream buffer exception_ptr if it has been set. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the exception, if it has been set; otherwise, <code>nullptr</code> will be returned.</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#aea1c7371c3f4de604c7aece1ee868f11">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa6c5d6cdc4f5dfcdd2859b4fa3872c95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::getc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single character from the stream without advancing the read position. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the byte. EOF if the read fails.</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a2de94cdebb61c424e083d04f8305b338">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2e03bfa260c8b9a2678e86c1c980c3a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;size_t&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::getn </td>
          <td>(</td>
          <td class="paramtype">_Out_writes_(count) _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_In_ size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads up to a given number of characters from the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The address of the target memory area.</td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of characters to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters read. O if the end of the stream is reached.</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a34bd5671e84946c5597a7090860693f0">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4acd807ca4d033cef91de1acd4f41fc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::getpos </td>
          <td>(</td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current read or write position in the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The I/O direction to seek (see remarks)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current position. EOF if the operation fails.</dd></dl>
<p>Some streams may have separate write and read cursors. For such streams, the direction parameter defines whether to move the read or the write cursor.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#afab8d95cff200323ab2cb803539e455b">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a3bb78aa602b1b5891be539e2afca4729">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#a658c28580b4cb1e7d7751ca1844ddf52">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a5930518c77994f3000dc0cd3ac1e39c7">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a7be25566723239022f11be55ec4396b8">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1e719975f42244d923c72e2e322faa07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::has_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>has_size<code> is used to determine whether a stream buffer supports <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html#a6d2e4ca19b7eda6cd5348768d9c3f548" title="Gets the size of the stream, if known. Calls to has_size will determine whether the result of size ca...">size()</a>. </code></code><code><code> </code></code></p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#aa91ebbdcb982d4d31531376a457502e7">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a11d3fd79869d4dbae639d09c270d30de">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a0e78e8e09631df4b23e17c66f275a101">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#aea293fd2f77d23b35fd769bb13387301">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a95e0854abbf6e1002372e5ffff3c4b97">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1e02ea1d54f3b1203787616bf8340430"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::in_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For any input stream, <code>in_avail</code> returns the number of characters that are immediately available to be consumed without blocking. May be used in conjunction with &lt;cref="::sbumpc method"/&gt; to read data without incurring the overhead of using tasks. </p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a78d87adbb1c2e175cd958ecbcbef6a36">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a87aec0d5fb4748b6a676d065023b14e3">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#ac388d4163132ff835b1ddfdefb12b9f9">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#ac38043172f7d0b9a36b45f52c1c57205">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#af7dc60cde0798585d46a842adedc122b">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a70ec23de40fe0390b6eeed04ac352de1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::is_eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>is_eof</code> is used to determine whether a read head has reached the end of the buffer. </p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a1c739ab9e5ce215f5ba5654d8cdf8fd0">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae803b65c032ea6e9dcd54b92e0c9d512"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream buffer is open. </p>
<p>No separation is made between open for reading and open for writing.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#ab16662ddfcca99b852b9421d1ea58507">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="acee850cc04e3ca57084ab11523e1db2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::nextc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the read position, then returns the next character without advancing again. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the character. EOF if the read fails.</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a59b6dc19c43e33bb9687dca6d6414e55">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a380b990b895a20224ca45d6c7c11190c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::putc </td>
          <td>(</td>
          <td class="paramtype">_CharType&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a single character to the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the character. EOF if the write operation fails</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a6dd5216351c5ed91d6661968719c1efc">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a4927b4f17f050f1fd10ed599cb49b836"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;size_t&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::putn </td>
          <td>(</td>
          <td class="paramtype">const _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a number of characters to the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the block of data to be written.</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters actually written, either 'count' or 0.</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a3065f53c165a6b100d5ff4ce00d477e4">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a48557a7d9d216500f879abc912b5f24f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;size_t&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::putn_nocopy </td>
          <td>(</td>
          <td class="paramtype">const _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a number of characters to the stream. Note: callers must make sure the data to be written is valid until the returned task completes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the block of data to be written.</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>task</code> that holds the number of characters actually written, either 'count' or 0.</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a558048d944a5fa3d59e2723a1733abbb">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a68390e9e8286f7911bde2dd91bbbf209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::release </td>
          <td>(</td>
          <td class="paramtype">_Out_writes_(count) _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_In_ size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a block of data acquired using ::acquire method. This frees the stream buffer to de-allocate the memory, if it so desires. Move the read position ahead by the count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to the block of data to be released.</td></tr>
    <tr><td class="paramname">count</td><td>The number of characters that were read.</td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a829c3e1b9a75cdfcc50eef9757bf9726">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a0466072dc98c90be1326f1a0269af131">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa3f5fd8cab84a41d75e8476015e83331"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::sbumpc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single character from the stream and advances the read position. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the character. <code>-1</code> if the read fails. <code>-2</code> if an asynchronous read is required</dd></dl>
<p>This is a synchronous operation, but is guaranteed to never block.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a6bc56f6145651a40ec62fafff1d7fcf0">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac759d4d90e6b33da98ed8f495c138dd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::scopy </td>
          <td>(</td>
          <td class="paramtype">_Out_writes_(count) _CharType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_In_ size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies up to a given number of characters from the stream, synchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The address of the target memory area.</td></tr>
    <tr><td class="paramname">count</td><td>The maximum number of characters to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters copied. O if the end of the stream is reached or an asynchronous read is required.</dd></dl>
<p>This is a synchronous operation, but is guaranteed to never block.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#aadcc77b99e3dc8ee3819472f1611f650">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2d7a83da4fc15bda3e02dbc91d21bc2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::seekoff </td>
          <td>(</td>
          <td class="paramtype">off_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::seekdir&#160;</td>
          <td class="paramname"><em>way</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seeks to a position given by a relative offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The relative position to seek to</td></tr>
    <tr><td class="paramname">way</td><td>The starting point (beginning, end, current) for the seek.</td></tr>
    <tr><td class="paramname">mode</td><td>The I/O direction to seek (see remarks)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position. EOF if the operation fails.</dd></dl>
<p>Some streams may have separate write and read cursors. For such streams, the mode parameter defines whether to move the read or the write cursor.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#ac4f681addd941123a660ef0c2acd4ed8">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a9808080aea0eb05b86159faefbcc4ded">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#a1ea35b3503c4c5019725bbeea8ea95e1">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a84838b4b0c8744033a66502af46c08e1">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#ab02ca807438f07bd855042c2c3f9fca9">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a771c9acc022390635bad4453f59a44dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::seekpos </td>
          <td>(</td>
          <td class="paramtype">pos_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seeks to the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The offset from the beginning of the stream.</td></tr>
    <tr><td class="paramname">direction</td><td>The I/O direction to seek (see remarks).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position. EOF if the operation fails.</dd></dl>
<p>Some streams may have separate write and read cursors. For such streams, the direction parameter defines whether to move the read or the write cursor.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a191bbcc02a82bf9adb80147b1e608baa">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a7fa36f1ebd1c1b3df9ac013cf4ca6281">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#ac19138ac861d195e0b079f53588aeaea">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#aa04c4bd7ed732a85db022f94337dd265">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#ade9aa941bea86f52a8fa18cb5d14d5a6">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a302f500fe45a006d6e264d320f87b3e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::set_buffer_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios_base::openmode&#160;</td>
          <td class="paramname"><em>direction</em> = <code>std::ios_base::in</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the stream buffer implementation to buffer or not buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to use for internal buffering, 0 if no buffering should be done.</td></tr>
    <tr><td class="paramname">direction</td><td>The direction of buffering (in or out)</td></tr>
  </table>
  </dd>
</dl>
<p>An implementation that does not support buffering will silently ignore calls to this function and it will not have any effect on what is returned by subsequent calls to ::buffer_size method.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a8ab85462baa0f80e502dced2587dd7db">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Implemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a8532562328084423ebf184d56103f63e">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#ad11103373e2f56d353276d0c843febfd">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#ad0d303f2025cb5160ed7d06d0b26a768">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__producer__consumer__buffer.html#a592befff2e1cd62552fc4a026a2c50c6">Concurrency::streams::details::basic_producer_consumer_buffer&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac9df9f0e827354a4f3d673e6d2643f52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int_type <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::sgetc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a single character from the stream without advancing the read position. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the character. EOF if the read fails. ::requires_async method if an asynchronous read is required</dd></dl>
<p>This is a synchronous operation, but is guaranteed to never block.</p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#abb8ebacdf59755dddc8330fbf4b8967c">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6d2e4ca19b7eda6cd5348768d9c3f548"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual utility::size64_t <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the stream, if known. Calls to <code>has_size</code> will determine whether the result of <code>size</code> can be relied on. </p>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a5f18fddf494a4383d9689b131e080150">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__file__buffer.html#a7e086cd919b71a4df34e829433871501">Concurrency::streams::details::basic_file_buffer&lt; _CharType &gt;</a>, <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__rawptr__buffer.html#aafb04c0576d1a02514a3ddcd72e03565">Concurrency::streams::details::basic_rawptr_buffer&lt; _CharType &gt;</a>, and <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__container__buffer.html#a7ba5b293e0e73d0e09ddc67fb398899c">Concurrency::streams::details::basic_container_buffer&lt; _CollectionType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a747f7e31451884a9448be43d11680285"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;void&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For output streams, flush any internally buffered data to the underlying medium. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the flush succeeds, <code>false</code> if not</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a14ad984f0acf241a825d4feaf24f027a">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5c2c264214da39baadca7755be4a9e0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CharType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpplx_1_1task.html">pplx::task</a>&lt;int_type&gt; <a class="el" href="class_concurrency_1_1streams_1_1details_1_1streambuf__state__manager.html">Concurrency::streams::details::streambuf_state_manager</a>&lt; _CharType &gt;::ungetc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retreats the read position, then returns the current character without advancing. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the character. EOF if the read fails. ::requires_async method if an asynchronous read is required</dd></dl>

<p>Implements <a class="el" href="class_concurrency_1_1streams_1_1details_1_1basic__streambuf.html#a9680265ce8eb48e167d502b45181a285">Concurrency::streams::details::basic_streambuf&lt; _CharType &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cpprest/<a class="el" href="astreambuf_8h_source.html">astreambuf.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
